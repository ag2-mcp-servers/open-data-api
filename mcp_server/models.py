# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T07:52:51+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import List, Optional

from pydantic import AnyUrl, BaseModel, ConfigDict, Field, RootModel, constr


class ATMService(Enum):
    Balance = 'Balance'
    BillPayments = 'BillPayments'
    CashDeposits = 'CashDeposits'
    CashWithdrawal = 'CashWithdrawal'
    CharityDonation = 'CharityDonation'
    ChequeBookRequest = 'ChequeBookRequest'
    ChequeDeposits = 'ChequeDeposits'
    FastCash = 'FastCash'
    MiniStatement = 'MiniStatement'
    MobileBankingRegistration = 'MobileBankingRegistration'
    MobilePaymentRegistration = 'MobilePaymentRegistration'
    MobilePhoneTopUp = 'MobilePhoneTopUp'
    OrderStatement = 'OrderStatement'
    PINActivation = 'PINActivation'
    PINChange = 'PINChange'


class AccessibilityType(Enum):
    AudioCashMachine = 'AudioCashMachine'
    AutomaticDoors = 'AutomaticDoors'
    ChairAccess = 'ChairAccess'
    DriveThru = 'DriveThru'
    ExternalRamp = 'ExternalRamp'
    InductionLoop = 'InductionLoop'
    InternalRamp = 'InternalRamp'
    LevelAccess = 'LevelAccess'
    LowerLevelCounter = 'LowerLevelCounter'
    WheelchairAccess = 'WheelchairAccess'


class Address(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BuildingNumberOrName: Optional[constr(min_length=1, max_length=350)] = Field(
        None,
        description='Number or Name that identifies the position of a building on a street',
    )
    Country: constr(pattern=r'[A-Z]{2}') = Field(
        ..., description='Nation with its own government'
    )
    CountrySubDivision: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='Identifies a subdivision of a country such as state, region, county',
    )
    OptionalAddressField: Optional[constr(min_length=1, max_length=350)] = Field(
        None, description='Directions for customers'
    )
    PostCode: constr(min_length=1, max_length=16) = Field(
        ...,
        description='Identifier consisting of a group of letters and/or numbers that is added to a postal address to assist the sorting of mail',
    )
    StreetName: constr(min_length=1, max_length=70) = Field(
        ..., description='Name of a street or thoroughfare'
    )
    TownName: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='Name of a built-up area, with defined boundaries, and a local government',
    )


class CurrencyItem(RootModel[constr(pattern=r'[A-Z]{3}')]):
    root: constr(pattern=r'[A-Z]{3}') = Field(
        ..., description='Active or Historic Currency Code'
    )


class GeographicLocation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Latitude: constr(pattern=r'^-?\d{1,3}\.\d{1,8}$') = Field(
        ..., description='The Latitude measured in decimal format according to ISO 213'
    )
    Longitude: constr(pattern=r'^-?\d{1,3}\.\d{1,8}$') = Field(
        ..., description='The longitude measured in decimal format according to ISO 213'
    )


class LocationCategory(Enum):
    Airport = 'Airport'
    BankSpecialisedOutlet = 'BankSpecialisedOutlet'
    BranchExternal = 'BranchExternal'
    BranchInternal = 'BranchInternal'
    BranchLobby = 'BranchLobby'
    BureauDeChange = 'BureauDeChange'
    CoachStation = 'CoachStation'
    CommercialSpaceInternal = 'CommercialSpaceInternal'
    ConvenienceStore = 'ConvenienceStore'
    ExhibitionCentre = 'ExhibitionCentre'
    FactoryOrOffice = 'FactoryOrOffice'
    FillingStation = 'FillingStation'
    FinancialInstitution = 'FinancialInstitution'
    GovernmentOffice = 'GovernmentOffice'
    Hospital = 'Hospital'
    Hotel = 'Hotel'
    KioskPod = 'KioskPod'
    LeisureCentre = 'LeisureCentre'
    PleasurePark = 'PleasurePark'
    PublicHouse = 'PublicHouse'
    RailwayStation = 'RailwayStation'
    RemoteUnit = 'RemoteUnit'
    RetailerDepartmentStore = 'RetailerDepartmentStore'
    RetailerOutlet = 'RetailerOutlet'
    SeaportTerminal = 'SeaportTerminal'
    ServiceStation = 'ServiceStation'
    ShoppingCentreExternal = 'ShoppingCentreExternal'
    ShoppingCentreInternal = 'ShoppingCentreInternal'
    StorageDepot = 'StorageDepot'
    SupermarketExternal = 'SupermarketExternal'
    SupermarketInternal = 'SupermarketInternal'
    UndergroundRailwayStation = 'UndergroundRailwayStation'
    UniversityOrCollege = 'UniversityOrCollege'


class MinimumValueDispensed(Enum):
    field_5 = '£5'
    field_10 = '£10'
    field_20 = '£20'
    field_50 = '£50'
    field_100 = '£100'


class TrademarkIPOCode(Enum):
    UK = 'UK'
    EU = 'EU'


class Brand(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    TrademarkID: constr(min_length=1, max_length=35) = Field(
        ...,
        description='The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted',
    )
    TrademarkIPOCode_1: TrademarkIPOCode = Field(
        ...,
        alias='TrademarkIPOCode',
        description='The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)',
    )


class OrganisationName(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    LegalName: constr(min_length=1, max_length=35) = Field(
        ..., description='Legal Name of the organisation'
    )


class ParentOrganisation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BIC: Optional[constr(pattern=r'[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?')] = Field(
        None, description='The BIC from the organisation'
    )
    LEI: Optional[constr(pattern=r'^[A-Z0-9]{18,18}[0-9]{2,2}$')] = Field(
        None, description='The LEI ID of the organisation'
    )
    OrganisationName_1: OrganisationName = Field(
        ..., alias='OrganisationName', description='Organisation Name'
    )


class Organisation(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Brand_1: Brand = Field(..., alias='Brand', description='Brand')
    ParentOrganisation_1: ParentOrganisation = Field(
        ..., alias='ParentOrganisation', description='Parent organisation'
    )


class Datum(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ATMID: constr(min_length=1, max_length=35) = Field(
        ...,
        description='ATM terminal device identification for the acquirer and the issuer',
    )
    ATMServices: List[ATMService] = Field(
        ..., description='Information about ATM services', min_length=1
    )
    AccessibilityTypes: Optional[List[AccessibilityType]] = Field(
        None, description='Information about the accessibility'
    )
    AdditionalATMServices: Optional[List[constr(min_length=1, max_length=350)]] = Field(
        None, description='ATM Service Description'
    )
    Address_1: Address = Field(..., alias='Address', description='Postal Address')
    BranchIdentification: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='Unique and unambiguous identification of a retail branch of a financial institution',
    )
    Currency: List[CurrencyItem] = Field(
        ..., description='Defines currency type available for dispense', min_length=1
    )
    GeographicLocation_1: GeographicLocation = Field(
        ..., alias='GeographicLocation', description='Geographic Coordinates'
    )
    LocationCategory_1: Optional[LocationCategory] = Field(
        None,
        alias='LocationCategory',
        description='Indicates the environment of the ATM',
    )
    MinimumValueDispensed_1: Optional[MinimumValueDispensed] = Field(
        None,
        alias='MinimumValueDispensed',
        description='Minimum currency denominations usually available',
    )
    Organisation_1: Organisation = Field(
        ..., alias='Organisation', description='Organisation'
    )
    SiteID: Optional[constr(min_length=1, max_length=35)] = Field(
        None, description='Site identifying code, where ATM is located'
    )
    SiteName: Optional[constr(min_length=1, max_length=35)] = Field(
        None, description='Site identifying name, where ATM is located'
    )
    SupportedLanguages: List[str] = Field(
        ..., description='Languages that the ATM supports', min_length=1
    )


class Agreement(Enum):
    Use_of_the_APIs_and_any_related_data_will_be_subject_to_the_terms_of_the_Open_Licence_and_subject_to_terms_and_conditions = 'Use of the APIs and any related data will be subject to the terms of the Open Licence and subject to terms and conditions'


class License(Enum):
    https___www_openbanking_org_uk_open_licence = (
        'https://www.openbanking.org.uk/open-licence'
    )


class TermsOfUse(Enum):
    https___www_openbanking_org_uk_terms = 'https://www.openbanking.org.uk/terms'


class Meta(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Agreement_1: Agreement = Field(..., alias='Agreement')
    LastUpdated: datetime
    License_1: License = Field(..., alias='License', description='Open Banking License')
    TermsOfUse_1: TermsOfUse = Field(
        ..., alias='TermsOfUse', description='Open Banking Terms of Use'
    )
    TotalResults: int


class AtmsGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[Datum]
    meta: Meta = Field(..., title='Meta data')


class Description(Enum):
    You_have_sent_a_request_which_could_not_be_understood_ = (
        'You have sent a request which could not be understood.'
    )


class Status(Enum):
    field_400 = '400'


class Title(Enum):
    Bad_request = 'Bad request'


class AtmsGetResponse1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description
    status: Status
    title: Title


class Description1(Enum):
    Your_client_has_failed_to_submit_a_request__and_a_timeout_has_occurred_ = (
        'Your client has failed to submit a request, and a timeout has occurred.'
    )


class Status1(Enum):
    field_408 = '408'


class Title1(Enum):
    Client_timeout = 'Client timeout'


class AtmsGetResponse2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description1
    status: Status1
    title: Title1


class Description2(Enum):
    You_have_requested_this_resource_too_often__Slow_down_ = (
        'You have requested this resource too often. Slow down.'
    )


class Status2(Enum):
    field_429 = '429'


class Title2(Enum):
    Too_many_requests = 'Too many requests'


class AtmsGetResponse3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description2
    status: Status2
    title: Title2


class Description3(Enum):
    An_error_occurred_on_the_server__No_further_information_is_available_ = (
        'An error occurred on the server. No further information is available.'
    )


class Status3(Enum):
    field_500 = '500'


class Title3(Enum):
    Internal_server_error = 'Internal server error'


class AtmsGetResponse4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description3
    status: Status3
    title: Title3


class Description4(Enum):
    The_service_is_temporarily_unavailable_ = 'The service is temporarily unavailable.'


class Status4(Enum):
    field_503 = '503'


class Title4(Enum):
    Service_temporarily_unavailable = 'Service temporarily unavailable'


class AtmsGetResponse5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description4
    status: Status4
    title: Title4


class AtmsGetResponse6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='Further details describing the error')
    status: str = Field(..., description='This corresponds to the HTTP status code')
    title: str = Field(..., description='A short title of the type of error')


class AtmsHeadResponse(BaseModel):
    pass


class AccessibilityTypes(Enum):
    AudioCashMachine = 'AudioCashMachine'
    AutomaticDoors = 'AutomaticDoors'
    ChairAccess = 'ChairAccess'
    DriveThru = 'DriveThru'
    ExternalRamp = 'ExternalRamp'
    InductionLoop = 'InductionLoop'
    InternalRamp = 'InternalRamp'
    LevelAccess = 'LevelAccess'
    LowerLevelCounter = 'LowerLevelCounter'
    WheelchairAccess = 'WheelchairAccess'


class Address1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BuildingNumberOrName: Optional[constr(min_length=1, max_length=350)] = Field(
        None,
        description='Number or Name that identifies the position of a building on a street',
    )
    Country: constr(pattern=r'[A-Z]{2}') = Field(
        ..., description='Nation with its own government'
    )
    CountrySubDivision: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='Identifies a subdivision of a country such as state, region, county',
    )
    OptionalAddressField: Optional[constr(min_length=1, max_length=350)] = Field(
        None, description='Directions for customers'
    )
    PostCode: Optional[constr(min_length=1, max_length=16)] = Field(
        None,
        description='Identifier consisting of a group of letters and/or numbers that is added to a postal address to assist the sorting of mail',
    )
    StreetName: Optional[constr(min_length=1, max_length=70)] = Field(
        None, description='Name of a street or thoroughfare'
    )
    TownName: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='Name of a built-up area, with defined boundaries, and a local government',
    )


class AlternatePhoneItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    AlternateTelephoneNumber: Optional[
        constr(pattern=r'^[+][0-9]{1,3}-[0-9()+-]{1,30}$')
    ] = Field(
        None,
        description='Collection of information that identifies a phone number, as defined by telecom services.',
    )
    AlternateTelephoneNumberDescription: Optional[
        constr(min_length=1, max_length=35)
    ] = Field(None, description='Description of the telephone number')


class BranchFacilitiesNameEnum(Enum):
    BusinessITSupport = 'BusinessITSupport'
    CollectionLockers = 'CollectionLockers'
    MeetingRooms = 'MeetingRooms'
    Parking = 'Parking'
    Wifi = 'Wifi'


class BranchMediatedServiceNameEnum(Enum):
    BureauDeChange = 'BureauDeChange'
    BusinessCounter = 'BusinessCounter'
    CardIssuanceFacility = 'CardIssuanceFacility'
    CounterServices = 'CounterServices'
    DriveThru = 'DriveThru'
    MortgageAdvisor = 'MortgageAdvisor'
    NightSafe = 'NightSafe'
    OnDemandCurrency = 'OnDemandCurrency'
    PremierCounter = 'PremierCounter'
    VideoBanking = 'VideoBanking'
    WheelChairAccess = 'WheelChairAccess'


class BranchSelfServeServiceNameEnum(Enum):
    AccountVerificationService = 'AccountVerificationService'
    AssistedServiceCounter = 'AssistedServiceCounter'
    BusinessDepositTerminal = 'BusinessDepositTerminal'
    CashChequeDepositMachineCoin = 'CashChequeDepositMachineCoin'
    CashChequeDepositMachineNoCoin = 'CashChequeDepositMachineNoCoin'
    ExternalAtmAudio = 'ExternalAtmAudio'
    ExternalAtmNoAudio = 'ExternalAtmNoAudio'
    ExternalQuickServicePoint = 'ExternalQuickServicePoint'
    InternalAtmAudio = 'InternalAtmAudio'
    InternalAtmNoAudio = 'InternalAtmNoAudio'
    InternalQuickServicePoint = 'InternalQuickServicePoint'
    LodgementDevice = 'LodgementDevice'
    OnlineBankingPoint = 'OnlineBankingPoint'
    QuickDeposit = 'QuickDeposit'
    SaturdayCounterService = 'SaturdayCounterService'
    SelfServiceAccountOpening = 'SelfServiceAccountOpening'
    StatementPrinter = 'StatementPrinter'


class BranchType(Enum):
    Physical = 'Physical'
    Mobile = 'Mobile'


class CustomerSegmentEnum(Enum):
    Business = 'Business'
    Corporate = 'Corporate'
    Personal = 'Personal'
    Premier = 'Premier'
    Private = 'Private'
    Select = 'Select'
    SME = 'SME'
    Wealth = 'Wealth'


class OpeningDay(Enum):
    Monday = 'Monday'
    Tuesday = 'Tuesday'
    Wednesday = 'Wednesday'
    Thursday = 'Thursday'
    Friday = 'Friday'
    Saturday = 'Saturday'
    Sunday = 'Sunday'
    Public_and_Bank_Holiday = 'Public and Bank Holiday'


class OpeningTime(BaseModel):
    ClosingTime: constr(
        pattern=r'^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$'
    ) = Field(
        ...,
        description='ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm',
    )
    OpeningDay_1: OpeningDay = Field(
        ..., alias='OpeningDay', description='Day of the week'
    )
    OpeningTime: constr(
        pattern=r'^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$'
    ) = Field(
        ...,
        description='ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm',
    )
    UnavailableFinishTime: Optional[
        constr(
            pattern=r'^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$'
        )
    ] = Field(
        None,
        description='ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm',
    )
    UnavailableStartTime: Optional[
        constr(
            pattern=r'^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$'
        )
    ] = Field(
        None,
        description='ISOTime, local time hh:mm:ss.sss or time in utc hh:mm:ss.sssZ or time with timezone hh:mm:ss.sss+hh:mm hh:mm:ss.sss-hh:mm',
    )


class Brand1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    TrademarkID: constr(min_length=1, max_length=35) = Field(
        ...,
        description='The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted',
    )
    TrademarkIPOCode_1: TrademarkIPOCode = Field(
        ...,
        alias='TrademarkIPOCode',
        description='The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)',
    )


class ParentOrganisation1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BIC: Optional[constr(pattern=r'[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?')] = Field(
        None, description='The BIC from the organisation'
    )
    LEI: Optional[constr(pattern=r'^[A-Z0-9]{18,18}[0-9]{2,2}$')] = Field(
        None, description='The LEI ID of the organisation'
    )
    OrganisationName_1: OrganisationName = Field(
        ..., alias='OrganisationName', description='Organisation Name'
    )


class Organisation1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Brand: Brand1 = Field(..., description='Brand')
    ParentOrganisation: ParentOrganisation1 = Field(
        ..., description='Parent organisation'
    )


class PlannedBranchClosureItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    EndDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='Date when a branch is due to re-open following temporary closure',
    )
    StartDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='Date when a branch is due to close temporarily or permanently',
    )


class Datum1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ATMAtBranch: bool = Field(
        ..., description='Indicated whether an ATM is at the branch'
    )
    AccessibilityTypes_1: Optional[AccessibilityTypes] = Field(
        None,
        alias='AccessibilityTypes',
        description='Information about the accessibility',
    )
    Address: Address1 = Field(..., description='Postal Address')
    AlternatePhone: Optional[List[AlternatePhoneItem]] = None
    ArrivalTime: Optional[
        constr(
            pattern=r'^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$'
        )
    ] = Field(None, description='Time that the mobile branch is scheduled to arrive')
    BranchDescription: Optional[constr(min_length=1, max_length=140)] = Field(
        None, description='Description of the branch'
    )
    BranchFacilitiesName: Optional[List[BranchFacilitiesNameEnum]] = Field(
        None, description='Information about branch facilities'
    )
    BranchIdentification: constr(min_length=1, max_length=35) = Field(
        ...,
        description='Unique and unambiguous identification of a retail branch of a financial institution',
    )
    BranchMediatedServiceName: Optional[List[BranchMediatedServiceNameEnum]] = Field(
        None, description='Information about mediated branch facilities'
    )
    BranchName: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='Name by which a party is known and which is usually used to identify that party',
    )
    BranchOtherFacilities: Optional[List[constr(min_length=1, max_length=350)]] = Field(
        None, description='Any other facilities not mentioned in BranchFacilitiesName'
    )
    BranchOtherMediatedServices: Optional[
        List[constr(min_length=1, max_length=350)]
    ] = Field(
        None, description='Mediated Services not described in BranchMediatedServiceName'
    )
    BranchOtherSelfServices: Optional[List[constr(min_length=1, max_length=350)]] = (
        Field(
            None,
            description='Self Services not described in BranchSelfServeServiceName',
        )
    )
    BranchPhoto: Optional[AnyUrl] = Field(
        None, description='Image related to the branch'
    )
    BranchSelfServeServiceName: Optional[List[BranchSelfServeServiceNameEnum]] = None
    BranchType_1: BranchType = Field(
        ..., alias='BranchType', description='Information on the type of branch'
    )
    CustomerSegment: List[CustomerSegmentEnum] = Field(
        ..., description='Customer segment which the branch is able to service'
    )
    DaysOfTheWeek: Optional[constr(min_length=1, max_length=35)] = Field(
        None,
        description='Description on when the mobile branch is available. e.g. The weekend of Glastonbury festival; or Mondays and during the shrimp season also Wednesdays',
    )
    DepartureTime: Optional[
        constr(
            pattern=r'^(([0-9]|0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].\d{3})|(^24:00:00\.000)(?:Z|[+-](?:2[0-3]|[01][0-9]):[0-5][0-9])?$'
        )
    ] = Field(None, description='Time that the mobile branch is scheduled to depart')
    FaxNumber: Optional[List[constr(pattern=r'^[+][0-9]{1,3}-[0-9()+-]{1,30}$')]] = (
        Field(
            None,
            description='Collection of information that identifies a FAX number, as defined by telecom services.',
        )
    )
    GeographicLocation_1: Optional[GeographicLocation] = Field(
        None, alias='GeographicLocation', description='Geographic Coordinates'
    )
    OpeningTimes: List[OpeningTime] = Field(
        ..., description='Branch Opening Times', min_length=1
    )
    Organisation: Organisation1 = Field(..., description='Organisation')
    ParkingLocation: Optional[constr(min_length=1, max_length=50)] = Field(
        None,
        description='Place where the mobile branch is located, such as between the news agent and the church.',
    )
    PlannedBranchClosure: Optional[List[PlannedBranchClosureItem]] = None
    StopName: Optional[constr(min_length=1, max_length=15)] = Field(
        None, description='Name of the stop of the mobile branch'
    )
    TelephoneNumber: constr(pattern=r'^[+][0-9]{1,3}-[0-9()+-]{1,30}$') = Field(
        ...,
        description='Collection of information that identifies a phone number, as defined by telecom services.',
    )


class Meta1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Agreement_1: Agreement = Field(..., alias='Agreement')
    LastUpdated: datetime
    License_1: License = Field(..., alias='License', description='Open Banking License')
    TermsOfUse_1: TermsOfUse = Field(
        ..., alias='TermsOfUse', description='Open Banking Terms of Use'
    )
    TotalResults: int


class BranchesGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[Datum1]
    meta: Meta1 = Field(..., title='Meta data')


class Description5(Enum):
    You_have_sent_a_request_which_could_not_be_understood_ = (
        'You have sent a request which could not be understood.'
    )


class Status5(Enum):
    field_400 = '400'


class Title5(Enum):
    Bad_request = 'Bad request'


class BranchesGetResponse1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description5
    status: Status5
    title: Title5


class Description6(Enum):
    Your_client_has_failed_to_submit_a_request__and_a_timeout_has_occurred_ = (
        'Your client has failed to submit a request, and a timeout has occurred.'
    )


class Status6(Enum):
    field_408 = '408'


class Title6(Enum):
    Client_timeout = 'Client timeout'


class BranchesGetResponse2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description6
    status: Status6
    title: Title6


class Description7(Enum):
    You_have_requested_this_resource_too_often__Slow_down_ = (
        'You have requested this resource too often. Slow down.'
    )


class Status7(Enum):
    field_429 = '429'


class Title7(Enum):
    Too_many_requests = 'Too many requests'


class BranchesGetResponse3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description7
    status: Status7
    title: Title7


class Description8(Enum):
    An_error_occurred_on_the_server__No_further_information_is_available_ = (
        'An error occurred on the server. No further information is available.'
    )


class Status8(Enum):
    field_500 = '500'


class Title8(Enum):
    Internal_server_error = 'Internal server error'


class BranchesGetResponse4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description8
    status: Status8
    title: Title8


class Description9(Enum):
    The_service_is_temporarily_unavailable_ = 'The service is temporarily unavailable.'


class Status9(Enum):
    field_503 = '503'


class Title9(Enum):
    Service_temporarily_unavailable = 'Service temporarily unavailable'


class BranchesGetResponse5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description9
    status: Status9
    title: Title9


class BranchesGetResponse6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='Further details describing the error')
    status: str = Field(..., description='This corresponds to the HTTP status code')
    title: str = Field(..., description='A short title of the type of error')


class BranchesHeadResponse(BaseModel):
    pass


class AccessChannel(Enum):
    ATM = 'ATM'
    Branch = 'Branch'
    BusinessCommercialCentre = 'BusinessCommercialCentre'
    CallCentre = 'CallCentre'
    MobileApps = 'MobileApps'
    MobileBanking = 'MobileBanking'
    Online = 'Online'
    Phone = 'Phone'
    Post = 'Post'
    PostOffice = 'PostOffice'
    RelationshipManager = 'RelationshipManager'
    Text = 'Text'


class CriteriaTypeEnum(Enum):
    CashDeposit = 'CashDeposit'
    Deposit = 'Deposit'
    DirectDebit = 'DirectDebit'
    InitialDeposit = 'InitialDeposit'
    InternetLogon = 'InternetLogon'
    MobileLogon = 'MobileLogon'
    RegularDeposit = 'RegularDeposit'


class BenefitDetailItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDescription: Optional[str] = Field(
        None, description='A textual explanation of what the benefit is'
    )
    BenefitID: Optional[str] = Field(
        None, description='Unique benefit identifier per organisation'
    )
    BenefitName: Optional[str] = Field(None, description='The name of the benefit')
    BenefitType: Optional[str] = Field(
        None, description='Type that represents the nature of the benefit'
    )
    BenefitValue: Optional[str] = Field(
        None,
        description='The value or values permissible for a specific benefit for an individual product representing a product characteristic',
    )
    Counter: Optional[int] = Field(
        None, description='Counter for the criteria (e.g. number of DD)'
    )
    CriteriaType: Optional[List[CriteriaTypeEnum]] = None
    DefaultToAccounts: Optional[bool] = Field(
        None, description='Is the benefit part of the default account'
    )
    MaximumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Maximum amount for the criteria'
    )
    MinimumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum amount for the criteria'
    )
    PromotionEndDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the end date is when the benefit is no longer applicable',
    )
    PromotionStartDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the start date is when the benefit comes into effect',
    )


class BenefitItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDetail: Optional[List[BenefitDetailItem]] = None
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date in days',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class BenefitSubType(Enum):
    FutureMultipleTerms = 'FutureMultipleTerms'
    Promotional = 'Promotional'
    Regular = 'Regular'


class BenefitGroupItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitItem_1: BenefitItem = Field(
        ..., alias='BenefitItem', description='Benefit Item'
    )
    BenefitSubType_1: Optional[BenefitSubType] = Field(
        None, alias='BenefitSubType', description='Benefit Subtype Code'
    )


class Benefits(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Benefit: bool = Field(
        ..., description='Describe  one or more benefits if they exist'
    )
    BenefitGroup: Optional[List[BenefitGroupItem]] = None


class CAPricingItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    ExchangeRateAdjustment: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None,
        description='The margin added, by certain card issuers, to the scheme rate in order to arrive at the exchange rate qouted as the reference exchange rate to the cardholder',
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class ProductState(Enum):
    FutureMultipleTerms = 'FutureMultipleTerms'
    Promotional = 'Promotional'
    Regular = 'Regular'


class CAPricingItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CAPricingItem: CAPricingItem1 = Field(..., description='Card Pricing')
    ProductState_1: ProductState = Field(
        ...,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )


class CardTypeEnum(Enum):
    BasicCard = 'BasicCard'
    BusinessQuickLodgeCard = 'BusinessQuickLodgeCard'
    Cashcard = 'Cashcard'
    ContactlessCashcard = 'ContactlessCashcard'
    ContactlessDebitMastercard = 'ContactlessDebitMastercard'
    ContactlessDebitVisa = 'ContactlessDebitVisa'
    DebitMastercard = 'DebitMastercard'
    VisaDebit = 'VisaDebit'
    DepositCard = 'DepositCard'
    OperatorCard = 'OperatorCard'
    POCACard = 'POCACard'


class CalculationFrequency(Enum):
    Daily = 'Daily'
    Weekly = 'Weekly'
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Half_Yearly = 'Half-Yearly'
    Yearly = 'Yearly'
    Overnight = 'Overnight'


class CalculationMethod(Enum):
    Banded = 'Banded'
    Tiered = 'Tiered'
    Whole = 'Whole'


class InterestRateType(Enum):
    Fixed = 'Fixed'
    Variable = 'Variable'


class RateComparisonType(Enum):
    APR = 'APR'
    AER = 'AER'
    Gross = 'Gross'
    Net = 'Net'
    RepApr = 'RepApr'


class InterestTier(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    APRAERRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='AER or APR Rate for comparison'
    )
    DailyChargeForMaximum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Special charge on tiered overdraft'
    )
    DailyChargeForMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Special charge on tiered overdraft'
    )
    InterestTier: Optional[str] = Field(None, description='Identifier for the tier')
    Rate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Rate being paid by the bank (gross)'
    )
    RateComparisonType_1: Optional[RateComparisonType] = Field(
        None, alias='RateComparisonType', description='Rate Comparison Type'
    )
    TierValueMaximum: Optional[constr(min_length=1, max_length=15)] = Field(
        None, description='Max Value of interst tier'
    )
    TierValueMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Lower value of interest tier'
    )


class PaymentMethod(Enum):
    Compound = 'Compound'
    PayAway = 'PayAway'
    SelfCredit = 'SelfCredit'
    SimpleInterest = 'SimpleInterest'


class CreditInterestItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CalculationFrequency_1: Optional[CalculationFrequency] = Field(
        None,
        alias='CalculationFrequency',
        description='How often is interest applied to account',
    )
    CalculationMethod_1: Optional[CalculationMethod] = Field(
        None, alias='CalculationMethod', description='Method for interest calculation'
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    EndDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If interest is charged on a specific date range as end date (often used for promotion)',
    )
    FixedInterestLength: Optional[int] = Field(
        None, description='Fixed interest length in days'
    )
    InterestNotes: Optional[str] = Field(
        None, description='Additional notes to supplement the interest details'
    )
    InterestRateType_1: Optional[InterestRateType] = Field(
        None, alias='InterestRateType', description='Credit Interest Payment Rate Type'
    )
    InterestTiers: Optional[List[InterestTier]] = None
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    PaymentMethod_1: Optional[PaymentMethod] = Field(
        None, alias='PaymentMethod', description='Credit Interest Payment Method Code'
    )
    StartDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If interest is charged on a specific date range as start date (often used for promotion)',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class InterestTierSubType(Enum):
    FutureMultipleTerms = 'FutureMultipleTerms'
    Promotional = 'Promotional'
    Regular = 'Regular'


class CreditInterestGroupItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CreditInterestItem_1: CreditInterestItem = Field(
        ..., alias='CreditInterestItem', description='Credit Interest item'
    )
    InterestTierSubType_1: Optional[InterestTierSubType] = Field(
        None,
        alias='InterestTierSubType',
        description='Describes if the offering is promotional, regular or a description of a future state',
    )


class CreditInterest(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CreditCharged: bool = Field(
        ...,
        description='Is credit paid to the account. The answer will be the condition of all other fields to be filled',
    )
    CreditInterestGroup: Optional[List[CreditInterestGroupItem]] = None


class CreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScoreEnum(Enum):
    Hard = 'Hard'
    Soft = 'Soft'


class CreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScoreEnum(Enum):
    Hard = 'Hard'
    Soft = 'Soft'


class EligibilityType(Enum):
    AnyBusinessCustomer = 'AnyBusinessCustomer'
    BusinessOnly = 'BusinessOnly'
    CreditCard = 'CreditCard'
    CreditScoring = 'CreditScoring'
    EmailAddress = 'EmailAddress'
    ExistingCustomers = 'ExistingCustomers'
    IdAndV = 'IdAndV'
    Mortgage = 'Mortgage'
    NoArrearsOnLoan = 'NoArrearsOnLoan'
    NoCustomerInArrears = 'NoCustomerInArrears'
    NoOverOverdraftThirtyDays = 'NoOverOverdraftThirtyDays'
    NoSoleUkAccountOrBankrupt = 'NoSoleUkAccountOrBankrupt'
    NTB = 'NTB'
    NTBBusiness = 'NTBBusiness'
    SoleStudentAccount = 'SoleStudentAccount'
    SoleUkAccount = 'SoleUkAccount'
    StudentsOnly = 'StudentsOnly'
    TwoMonthsOfCourseStart = 'TwoMonthsOfCourseStart'
    UCASFulltimeTwoYears = 'UCASFulltimeTwoYears'


class MarketingEligibilityEnum(Enum):
    ExistingCustomers = 'ExistingCustomers'
    NewCustomersOnly = 'NewCustomersOnly'
    SwitchersOnly = 'SwitchersOnly'
    StartUp = 'StartUp'


class MinimumIncomeFrequency(Enum):
    AcademicTerm = 'AcademicTerm'
    HalfYearly = 'HalfYearly'
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Weekly = 'Weekly'
    Yearly = 'Yearly'


class ResidencyRestrictedRegion(Enum):
    UK = 'UK'
    EEA = 'EEA'
    EU = 'EU'
    EFTA = 'EFTA'
    GB___ENG = 'GB - ENG'
    GB___NIR = 'GB - NIR'
    GB___SCT = 'GB - SCT'
    GB___WLS = 'GB - WLS'
    IRL = 'IRL'


class SingleJointIncome(Enum):
    Joint = 'Joint'
    SoleIncome = 'SoleIncome'
    SoleOrJoint = 'SoleOrJoint'
    Turnover = 'Turnover'


class Eligibility(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    AgeRestricted: bool = Field(
        ..., description="Indicates a customer's age is part of eligibility criteria"
    )
    AnnualBusinessTurnover: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Annual Business Turnover'
    )
    AnnualBusinessTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Annual Business Turnover Currency'
    )
    Description: str = Field(..., description='One paragraph detailing the eligibility')
    EligibilityName: Optional[str] = Field(
        None,
        description='Free text description, denotes non standard eligibilities not included in the code list',
    )
    EligibilityNotes: Optional[str] = Field(
        None,
        description='Optional additional notes to supplement the eligibility conditions. Only used for very specific conditions',
    )
    EligibilityType_1: Optional[EligibilityType] = Field(
        None, alias='EligibilityType', description='Eligibility type'
    )
    IncomeCondition: Optional[str] = Field(
        None,
        description='Stipulates any particular definition of income that applies to the income eligibility and/or method by which income must paid into the account (eg Salary DD)',
    )
    IncomeTurnoverRelated: bool = Field(
        ..., description='Indicates if eligibility linked to income'
    )
    MarketingEligibility: Optional[List[MarketingEligibilityEnum]] = None
    MaxNumberOfAccounts: Optional[str] = Field(
        None, description='Maximum number of the same prodcut the customer may hold'
    )
    MaximumAge: Optional[int] = Field(
        None, description='Maximum age, in years, allowed to hold the account'
    )
    MaximumAgeToOpen: Optional[int] = Field(
        None, description='Maximum age, in years, to open an account'
    )
    MaximumOpeningAmount: Optional[bool] = Field(
        None, description='A maximum amount to be deposited at opening'
    )
    MinIncomeTurnoverPaidIntoAccount: Optional[int] = Field(
        None, description='Minimum Income Amount required to paid into the account'
    )
    MinimumAge: Optional[int] = Field(
        None, description='Minimum age, in years, required to hold an account'
    )
    MinimumDeposit: Optional[bool] = Field(
        None, description='A minimum deposit required to hold this account'
    )
    MinimumIncomeFrequency_1: Optional[MinimumIncomeFrequency] = Field(
        None,
        alias='MinimumIncomeFrequency',
        description='The frequency that the minimum mentioned before is deposited in the account. Yearly is very important for premium accounts',
    )
    MinimumIncomeTurnoverAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(
            None, description='Minimum income / Turnover required to hold the product'
        )
    )
    MinimumIncomeTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum income / Turnover Currency'
    )
    MinimumOperatingBalance: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Operating Balance'
    )
    MinimumOperatingBalanceCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum Operating Balance currency'
    )
    MinimumOperatingBalanceExists: Optional[bool] = Field(
        None, description='Is there a Minimum Operating Balance?'
    )
    OpeningDepositMaximumAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(None, description='Maximum Amount to be depositing at opening')
    )
    OpeningDepositMaximumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OpeningDepositMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Amount to be held on account'
    )
    OpeningDepositMinimumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OtherFinancialHoldingRequired: bool = Field(
        ...,
        description='Indicates that it is necessary to hold another product with the bank in order to be eligible for this product or feature',
    )
    PreviousBankruptcy: bool = Field(
        ...,
        description='Describes if a previous bankruptcy / insolvency disqualfies for this account Details in ELI-280',
    )
    ResidencyRestricted: bool = Field(
        ...,
        description="Indicates a customer's residency forms part of the eligibility criteria",
    )
    ResidencyRestrictedRegion_1: Optional[ResidencyRestrictedRegion] = Field(
        None,
        alias='ResidencyRestrictedRegion',
        description='Indicates a customer must be current resident of a geographic area/country',
    )
    SingleJointIncome_1: Optional[SingleJointIncome] = Field(
        None,
        alias='SingleJointIncome',
        description='Minimum Income Source. For certain products a minimum income is required. This can be mandated as to the single income or to a joint income. This field describes this',
    )
    ThirdSectorOrganisations: bool = Field(
        ...,
        description='Is the product available to operate as a Clubs or Societies account?',
    )


class FeatureSubType(Enum):
    FutureMultipleTerms = 'FutureMultipleTerms'
    Promotional = 'Promotional'
    Regular = 'Regular'


class FeatureDetail(BaseModel):
    CriteriaType: Optional[str] = Field(
        None,
        description='Criteria that is required in order to be eligible for the feature',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeatureDescription: Optional[str] = Field(
        None, description='A textual explanation of what the feature'
    )
    FeatureName: Optional[str] = Field(None, description='The name of the feature')
    FeatureSubType_1: Optional[FeatureSubType] = Field(
        None, alias='FeatureSubType', description=''
    )
    FeatureType: Optional[str] = Field(
        None, description='Type that represents the nature of the feature'
    )
    FeatureValue: Optional[str] = Field(
        None,
        description='The value or values permissible for a specific feature for an individual product representing a product characteristic',
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeatureItem(BaseModel):
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    ExistingFeature: bool = Field(
        ..., description='Indicates whether the account has any feature'
    )
    FeatureDetails: Optional[List[FeatureDetail]] = Field(
        None, description='Feature details'
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    ProductState_1: Optional[ProductState] = Field(
        None,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeeFrequency(Enum):
    AcademicTerm = 'AcademicTerm'
    AccountClosing = 'AccountClosing'
    AccountOpening = 'AccountOpening'
    AtTimeOfLoanRepayment = 'AtTimeOfLoanRepayment'
    ChargingPeriod = 'ChargingPeriod'
    Daily = 'Daily'
    EveryFiveBusinessDays = 'EveryFiveBusinessDays'
    Item = 'Item'
    Monthly = 'Monthly'
    OnAccountAnniversary = 'OnAccountAnniversary'
    PerHour = 'PerHour'
    PerOccurrence = 'PerOccurrence'
    PerSheet = 'PerSheet'
    PerTransactionAmount = 'PerTransactionAmount'
    PerTransactionPercentage = 'PerTransactionPercentage'
    Quarterly = 'Quarterly'
    SixMonthly = 'SixMonthly'
    StartOfLoan = 'StartOfLoan'
    StatementMonthly = 'StatementMonthly'
    Weekly = 'Weekly'
    Yearly = 'Yearly'


class FeeSubDetails(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeFrequency_1: FeeFrequency = Field(
        ..., alias='FeeFrequency', description='Triggering frequency of the fee'
    )
    FeeHigherTier: Optional[int] = Field(
        None,
        description='Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range',
    )
    FeeLowerTier: Optional[int] = Field(
        None,
        description='Lower occurrence / range boundary e.g. For returned cheques this could be 0, which means the first returned cheque fits into this range',
    )
    FeeMax: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeMin: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='% Rate'
    )
    FeesAndChargesNotes: Optional[str] = Field(
        None, description='Supplementary information for fees and charges'
    )
    Negotiable: bool = Field(
        ...,
        description='Indicates that this Fee Rate or Fee Amount is negotiable based on risk or other factor',
    )
    RepresentativeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Representative Rate'
    )


class FeeType(Enum):
    Other = 'Other'
    ATMDonation = 'ATMDonation'
    ATMDeposATMPaidIn = 'ATMDeposATMPaidIn'
    ReportCertBalance = 'ReportCertBalance'
    ATMAbroadConVisaCredit = 'ATMAbroadConVisaCredit'
    ATMAbroadConVisaDebit = 'ATMAbroadConVisaDebit'
    ATMCardnetEnvIn = 'ATMCardnetEnvIn'
    ATMCashGroupATMCreditCard = 'ATMCashGroupATMCreditCard'
    ATMCashNonGroupATMCredittcard = 'ATMCashNonGroupATMCredittcard'
    ATMCashGroupATMDebitCard = 'ATMCashGroupATMDebitCard'
    ATMCashNonGroupATMDebitcard = 'ATMCashNonGroupATMDebitcard'
    ATMConGroupATM = 'ATMConGroupATM'
    ATMAbroad = 'ATMAbroad'
    ATMForeignCashDebCard = 'ATMForeignCashDebCard'
    ATMAbroadGoldVisaDebit = 'ATMAbroadGoldVisaDebit'
    ATMSpainCashCard = 'ATMSpainCashCard'
    ATMSpainDebitCard = 'ATMSpainDebitCard'
    ATMSpainConversionDebitCard = 'ATMSpainConversionDebitCard'
    ATMSpainConversionCashCard = 'ATMSpainConversionCashCard'
    ATMNonSterlingWithdrawal = 'ATMNonSterlingWithdrawal'
    ATMAbroadVisaCredit = 'ATMAbroadVisaCredit'
    ATMAbroadVisaDebit = 'ATMAbroadVisaDebit'
    ATMAbroadConVisaGoldDebit = 'ATMAbroadConVisaGoldDebit'
    ATMWidthdrawCash = 'ATMWidthdrawCash'
    BACSOnLineAncilliary = 'BACSOnLineAncilliary'
    BACSBatch = 'BACSBatch'
    BACSOnLineFile = 'BACSOnLineFile'
    BACSFileItem = 'BACSFileItem'
    BACSOnLineSetup_ = 'BACSOnLineSetup '
    BACSItem = 'BACSItem'
    BACSItemInterbranch = 'BACSItemInterbranch'
    BACSBulkBatch = 'BACSBulkBatch'
    BACSOnLineOverlimit = 'BACSOnLineOverlimit'
    BACSOnLinePayment = 'BACSOnLinePayment'
    BACSRecallItem = 'BACSRecallItem'
    BACSOnLineService = 'BACSOnLineService'
    BACSBulkInternet = 'BACSBulkInternet'
    BACSTELDirDebSmartCard = 'BACSTELDirDebSmartCard'
    BACSTELDirDebWebInit = 'BACSTELDirDebWebInit'
    BACSTELirDebWebInit = 'BACSTELirDebWebInit'
    BACSTELDirDebOverlimit = 'BACSTELDirDebOverlimit'
    BACSTELDirDebPayment = 'BACSTELDirDebPayment'
    BACSTELDirDebService = 'BACSTELDirDebService'
    BACSTELDirDebAncilliary = 'BACSTELDirDebAncilliary'
    BACSDirectItemProfile = 'BACSDirectItemProfile'
    BACSTELAncilliary = 'BACSTELAncilliary'
    BACSTELSmartCard = 'BACSTELSmartCard'
    BACSTELFile = 'BACSTELFile'
    BACSTELSetup_ = 'BACSTELSetup '
    BACSTELOverlimit = 'BACSTELOverlimit'
    BACSTELPayment = 'BACSTELPayment'
    BACSTELService = 'BACSTELService'
    CHAPSOutBranch = 'CHAPSOutBranch'
    CHAPSCancellation = 'CHAPSCancellation'
    CHAPSOutOnlineDepositAcc = 'CHAPSOutOnlineDepositAcc'
    CHAPSIn = 'CHAPSIn'
    CHAPSOutInterBank = 'CHAPSOutInterBank'
    CHAPSInterBank = 'CHAPSInterBank'
    CHAPSOutPost = 'CHAPSOutPost'
    CHAPSOutInterBranch = 'CHAPSOutInterBranch'
    CHAPSOut = 'CHAPSOut'
    CHAPSOutOnline = 'CHAPSOutOnline'
    CHAPSandForeignPay = 'CHAPSandForeignPay'
    CHAPSOutManual = 'CHAPSOutManual'
    CardCardReplacement = 'CardCardReplacement'
    DraftsCounter = 'DraftsCounter'
    DraftsBankers = 'DraftsBankers'
    DraftsIntlPayableAbroad = 'DraftsIntlPayableAbroad'
    DraftsLostStolen = 'DraftsLostStolen'
    CardPersonalisedCard = 'CardPersonalisedCard'
    DraftsIntlStoppedCancelled = 'DraftsIntlStoppedCancelled'
    EuroChqXLess = 'EuroChqXLess'
    EuroChqXPlus = 'EuroChqXPlus'
    FPSOutFutureDated = 'FPSOutFutureDated'
    FPSOutImmediate = 'FPSOutImmediate'
    FPSOut = 'FPSOut'
    FPSOutOwn = 'FPSOutOwn'
    FPSInBranch = 'FPSInBranch'
    FPSUKPayUrgent = 'FPSUKPayUrgent'
    LegalArticlesReport = 'LegalArticlesReport'
    LegalSealing = 'LegalSealing'
    LegalBondAndGuarantee = 'LegalBondAndGuarantee'
    LegalCourtOrder = 'LegalCourtOrder'
    LegalCoSearch = 'LegalCoSearch'
    LegalDepositAssignment = 'LegalDepositAssignment'
    LegalGuaranteePrep = 'LegalGuaranteePrep'
    LegalLifePolicyPrepCo = 'LegalLifePolicyPrepCo'
    LegalLifePolicyPrepPersonal = 'LegalLifePolicyPrepPersonal'
    LegalPriorityPariPassu = 'LegalPriorityPariPassu'
    LegalSubordinationAgreement = 'LegalSubordinationAgreement'
    DirDebDirectDebitAdmin = 'DirDebDirectDebitAdmin'
    DirDebDirectDebitCancel = 'DirDebDirectDebitCancel'
    IntlPayBIBForeignLimit = 'IntlPayBIBForeignLimit'
    IntlPayCreditTransCust = 'IntlPayCreditTransCust'
    IntlPayCreditTransNonCust = 'IntlPayCreditTransNonCust'
    IntlPayUrgentPaymentForeign = 'IntlPayUrgentPaymentForeign'
    IntlPayExpressMoneyMover = 'IntlPayExpressMoneyMover'
    IntlPayEEAPayUrgent = 'IntlPayEEAPayUrgent'
    IntlPayIrishPayUrgent = 'IntlPayIrishPayUrgent'
    IntlPayEEAPay = 'IntlPayEEAPay'
    IntlPayForeignIn1CPlus = 'IntlPayForeignIn1CPlus'
    IntlPayForeignPaymentInUKAcc = 'IntlPayForeignPaymentInUKAcc'
    IntlPayForeignCharge = 'IntlPayForeignCharge'
    IntlPayForeignCancellation = 'IntlPayForeignCancellation'
    IntlPayForeignStandardEUEuroBIC = 'IntlPayForeignStandardEUEuroBIC'
    IntlPayFXFeeRate = 'IntlPayFXFeeRate'
    IntlPayForeignInternet = 'IntlPayForeignInternet'
    IntlPayForeign = 'IntlPayForeign'
    IntlPayForeignInbound = 'IntlPayForeignInbound'
    IntlPayFXPaymentOut = 'IntlPayFXPaymentOut'
    IntlPayForeignInSub1C = 'IntlPayForeignInSub1C'
    IntlPayFXRate = 'IntlPayFXRate'
    IntlPayForeignStandardEUEuroNoBIC = 'IntlPayForeignStandardEUEuroNoBIC'
    IntlPayFXPaymentOutIR = 'IntlPayFXPaymentOutIR'
    IntlPayFXFee = 'IntlPayFXFee'
    IntlPayPurchaseNonSterling = 'IntlPayPurchaseNonSterling'
    IntlPayPostPaymentForeign = 'IntlPayPostPaymentForeign'
    IntlPayPurchaseRateNonSterling = 'IntlPayPurchaseRateNonSterling'
    IntlPayPaymentTracing = 'IntlPayPaymentTracing'
    IntlPayStandardMoneyMover = 'IntlPayStandardMoneyMover'
    IntlPayMT101Transaction = 'IntlPayMT101Transaction'
    IntlPayTransNonSterling = 'IntlPayTransNonSterling'
    IntlPayTransRateNonSterling = 'IntlPayTransRateNonSterling'
    IntlPayForeignUrgentEUEuroBIC = 'IntlPayForeignUrgentEUEuroBIC'
    IntlPayForeignUrgentEUEuroNoBIC = 'IntlPayForeignUrgentEUEuroNoBIC'
    IntlPayUrgentPaymentGroup = 'IntlPayUrgentPaymentGroup'
    IntlPayUrgentPaymentUK = 'IntlPayUrgentPaymentUK'
    IntlPayUSAPayUrgent = 'IntlPayUSAPayUrgent'
    IntlPayCurrencyPurchase = 'IntlPayCurrencyPurchase'
    IntlPayWorldpayPayment = 'IntlPayWorldpayPayment'
    IntlPayCurrencyWithdraw = 'IntlPayCurrencyWithdraw'
    InvPayBankDetailsWrong = 'InvPayBankDetailsWrong'
    InvPayForeignBCNR = 'InvPayForeignBCNR'
    InvPayForeignRecall = 'InvPayForeignRecall'
    InvGeneralInq = 'InvGeneralInq'
    InvOldInstruction = 'InvOldInstruction'
    InvPayPaymentRecall = 'InvPayPaymentRecall'
    InvPayReturnDebitXVLess = 'InvPayReturnDebitXVLess'
    InvPayReturnDebitXVPlus = 'InvPayReturnDebitXVPlus'
    InvPayStopPayment = 'InvPayStopPayment'
    InvPayStandingOrdUnpaid = 'InvPayStandingOrdUnpaid'
    SafeKeepAccess = 'SafeKeepAccess'
    SafeKeepDeedMedium = 'SafeKeepDeedMedium'
    SafeKeepingEnvelope = 'SafeKeepingEnvelope'
    SafeKeepingInspection = 'SafeKeepingInspection'
    SafeKeepingLargeItem = 'SafeKeepingLargeItem'
    SafeKeepMultipleItems = 'SafeKeepMultipleItems'
    SafeKeepingParcel = 'SafeKeepingParcel'
    SafeKeepDeedSmall = 'SafeKeepDeedSmall'
    SafeKeepOneItem = 'SafeKeepOneItem'
    SafeKeepSafeCustody = 'SafeKeepSafeCustody'
    LoanArrangementFeePC = 'LoanArrangementFeePC'
    LoanArrangement = 'LoanArrangement'
    LoanEarlyRepayment = 'LoanEarlyRepayment'
    LoanLatePayment = 'LoanLatePayment'
    LoanSMEUnsecuredLoan = 'LoanSMEUnsecuredLoan'
    LoanTieredArrangement = 'LoanTieredArrangement'
    NightSafeNightSafeBankOpen = 'NightSafeNightSafeBankOpen'
    NightSafeCreditSub5K = 'NightSafeCreditSub5K'
    NightSafeNightSafe = 'NightSafeNightSafe'
    NightSafeNightSafePaidIn = 'NightSafeNightSafePaidIn'
    OverdraftAnnualReview = 'OverdraftAnnualReview'
    OverdraftTempOverdraft = 'OverdraftTempOverdraft'
    OverdraftUnauthorisedBorrowing = 'OverdraftUnauthorisedBorrowing'
    POPostOfficeCounterCredit = 'POPostOfficeCounterCredit'
    POPostOfficeCashCredit = 'POPostOfficeCashCredit'
    POPostOfficeCashOut = 'POPostOfficeCashOut'
    POPostOfficeWithdrawal = 'POPostOfficeWithdrawal'
    ChqBookTheftLossAllStopped = 'ChqBookTheftLossAllStopped'
    ChqIssuedCurrencyAcc = 'ChqIssuedCurrencyAcc'
    ChqCopy = 'ChqCopy'
    ChqDraft = 'ChqDraft'
    ChqIn = 'ChqIn'
    ChqDraftSterling = 'ChqDraftSterling'
    ChqOutIssued = 'ChqOutIssued'
    ChqSpecialChqPresentation = 'ChqSpecialChqPresentation'
    ChqCounterCheque = 'ChqCounterCheque'
    ChqChequeswithStatement = 'ChqChequeswithStatement'
    ChqStopped = 'ChqStopped'
    ChqTrans = 'ChqTrans'
    ChqDraftFX = 'ChqDraftFX'
    ChqForeignCourier = 'ChqForeignCourier'
    ChqForeignNegTenThou = 'ChqForeignNegTenThou'
    ChqForeignNegHundred = 'ChqForeignNegHundred'
    ChequeForeignBankDivi = 'ChequeForeignBankDivi'
    ChqForeignNegFiftyThou = 'ChqForeignNegFiftyThou'
    ChqPensionCheque = 'ChqPensionCheque'
    ChequeForeignOtherDivi = 'ChequeForeignOtherDivi'
    ChqForeignNegFiveThou = 'ChqForeignNegFiveThou'
    ChqForeignNegMax = 'ChqForeignNegMax'
    ChqForeignGBPMMDPlus = 'ChqForeignGBPMMDPlus'
    ChqGiftCheque = 'ChqGiftCheque'
    ChqCounterLodgement = 'ChqCounterLodgement'
    ChqCashDropLodgement = 'ChqCashDropLodgement'
    ChqChequePhotocopy = 'ChqChequePhotocopy'
    ChqPostOfficeCredit = 'ChqPostOfficeCredit'
    ChqPostOfficeChequeCollected = 'ChqPostOfficeChequeCollected'
    ChqChequeRetrieval = 'ChqChequeRetrieval'
    ChqReconcilliationPerTrans = 'ChqReconcilliationPerTrans'
    ChqSpecialPresentationCount = 'ChqSpecialPresentationCount'
    ChqSpecialPresentationPTT = 'ChqSpecialPresentationPTT'
    ChqUnpaidCharge = 'ChqUnpaidCharge'
    ChqUnpaidTransIn = 'ChqUnpaidTransIn'
    ChqUnpaidTransOut = 'ChqUnpaidTransOut'
    ChqUnpaidCheque = 'ChqUnpaidCheque'
    ReportAuditLetter = 'ReportAuditLetter'
    ReportFAXAdviceAdditional = 'ReportFAXAdviceAdditional'
    ReportTelAdviceAdditional = 'ReportTelAdviceAdditional'
    ReportCreditHistory = 'ReportCreditHistory'
    ReportCertInterestDuplicate = 'ReportCertInterestDuplicate'
    ReportCertInterest = 'ReportCertInterest'
    ReportCreditHistoryAdditionalInYear = 'ReportCreditHistoryAdditionalInYear'
    ReportForeignStatusEnqElec = 'ReportForeignStatusEnqElec'
    ReportForeignStatusEnq = 'ReportForeignStatusEnq'
    ReportCashBackorInterestAnal = 'ReportCashBackorInterestAnal'
    ReportStatementChqDaily = 'ReportStatementChqDaily'
    ReportStatementChqFortnightly = 'ReportStatementChqFortnightly'
    ReportStatementChqMonthly = 'ReportStatementChqMonthly'
    ReportStatementChqWeekly = 'ReportStatementChqWeekly'
    ReportStatementAndDiviChq = 'ReportStatementAndDiviChq'
    ReportReference = 'ReportReference'
    ReportReferralItem = 'ReportReferralItem'
    ReportStatementByATM = 'ReportStatementByATM'
    ReportStatementByBranch = 'ReportStatementByBranch'
    ReportStatementCopyRegular = 'ReportStatementCopyRegular'
    ReportStatusEnquiry = 'ReportStatusEnquiry'
    ReportStatementFrequent = 'ReportStatementFrequent'
    ReportStatementMonthly = 'ReportStatementMonthly'
    ReportStatementCopy1 = 'ReportStatementCopy1'
    ReportStatementToBranch = 'ReportStatementToBranch'
    ReportSMSTextMiniStatementorAlert = 'ReportSMSTextMiniStatementorAlert'
    ReportStatementFortnightly = 'ReportStatementFortnightly'
    ReportSMSTextMiniStatementWoM = 'ReportSMSTextMiniStatementWoM'
    ReportSMSTextAlertBalance = 'ReportSMSTextAlertBalance'
    ReportSMSTextAlert = 'ReportSMSTextAlert'
    ReportTaxCert = 'ReportTaxCert'
    ReportWeeklyStatement = 'ReportWeeklyStatement'
    ReportTextMessageBanking = 'ReportTextMessageBanking'
    SEPACancellation = 'SEPACancellation'
    SEPABranch = 'SEPABranch'
    SEPACredit = 'SEPACredit'
    SEPADirectDebit = 'SEPADirectDebit'
    SEPAIn = 'SEPAIn'
    SEPAEuro = 'SEPAEuro'
    SEPAOut = 'SEPAOut'
    SEPAUnpaid = 'SEPAUnpaid'
    SEPAWinbitsAnnual_Service = 'SEPAWinbitsAnnual Service'
    SEPAWinbitsTransaction = 'SEPAWinbitsTransaction'
    TransBillPaymentBranch = 'TransBillPaymentBranch'
    TransBillCollect = 'TransBillCollect'
    TransTelephoneBillPayment = 'TransTelephoneBillPayment'
    TransBankPayment = 'TransBankPayment'
    TransBillPaymentTelephone = 'TransBillPaymentTelephone'
    TransCorrespondentBankFee = 'TransCorrespondentBankFee'
    TransCreditTransferUKDifferent = 'TransCreditTransferUKDifferent'
    TransCreditTransferUKSame = 'TransCreditTransferUKSame'
    TransCredit = 'TransCredit'
    TransCreditTransfer = 'TransCreditTransfer'
    TransBranchCredit = 'TransBranchCredit'
    TransDebit = 'TransDebit'
    TransDebCardDeb = 'TransDebCardDeb'
    TransUKDirDeb = 'TransUKDirDeb'
    TransManualDeb = 'TransManualDeb'
    TransBuyForeignWithGBP = 'TransBuyForeignWithGBP'
    TransGoodValueReq = 'TransGoodValueReq'
    TransSWIFTOutUKForeign = 'TransSWIFTOutUKForeign'
    TransInconpleteInstruction = 'TransInconpleteInstruction'
    TransManualEntries = 'TransManualEntries'
    TransManualTrans = 'TransManualTrans'
    TransNonSterling = 'TransNonSterling'
    TransPOSSaleForeign = 'TransPOSSaleForeign'
    TransPriPaymentPost = 'TransPriPaymentPost'
    TransPOSSaleUK = 'TransPOSSaleUK'
    TransReturnPayment = 'TransReturnPayment'
    TransReconciliationPerTrans = 'TransReconciliationPerTrans'
    TransStandingOrdAdmin = 'TransStandingOrdAdmin'
    TransStandingOrd = 'TransStandingOrd'
    TransStandingOrdManPay = 'TransStandingOrdManPay'
    TransTravellersChqOtherBank = 'TransTravellersChqOtherBank'
    TransTelBusiPriPaymentForeignToUKAcc = 'TransTelBusiPriPaymentForeignToUKAcc'
    TransTeleItem = 'TransTeleItem'
    TransTelBusiPriPaymentToGrpAcc = 'TransTelBusiPriPaymentToGrpAcc'
    TransTravellersChqRate = 'TransTravellersChqRate'
    TransTransferExGroup = 'TransTransferExGroup'
    TransUnauthorisedPaidTrans = 'TransUnauthorisedPaidTrans'
    TransUrgentPaymentPostal = 'TransUrgentPaymentPostal'
    TransUnpaidTrans = 'TransUnpaidTrans'
    TransTelBusiPriPaymentToNonGrpAcc = 'TransTelBusiPriPaymentToNonGrpAcc'
    TransSWIFTOutNonEEASterling = 'TransSWIFTOutNonEEASterling'
    AutoAutoCredit = 'AutoAutoCredit'
    AutoAutomatedEntries = 'AutoAutomatedEntries'
    AutoAutoCreditPhoneInet = 'AutoAutoCreditPhoneInet'
    AutoAutomatedTrans = 'AutoAutomatedTrans'
    AutoDebitCardCommercial = 'AutoDebitCardCommercial'
    AutoFPSAutoCredit = 'AutoFPSAutoCredit'
    VisaConvertAbroadForeign = 'VisaConvertAbroadForeign'
    VisaBureauDeChange = 'VisaBureauDeChange'
    VisaTravellersChqorCurrency = 'VisaTravellersChqorCurrency'
    OnlineInternetBillPayment = 'OnlineInternetBillPayment'
    OnlineBusinessOnlineEuroPayment = 'OnlineBusinessOnlineEuroPayment'
    OnlineBusinessOnlineUrgentEuroPayment = 'OnlineBusinessOnlineUrgentEuroPayment'
    OnlineBusinessOnlineForeignPayment = 'OnlineBusinessOnlineForeignPayment'
    OnlineInterbankTransfer = 'OnlineInterbankTransfer'
    OnlineInterbankPerTransfer = 'OnlineInterbankPerTransfer'
    OnlineInterbranchTransfer = 'OnlineInterbranchTransfer'
    OnlineInterbranchPerTransfer = 'OnlineInterbranchPerTransfer'
    OnlineSubscriptionMonthly = 'OnlineSubscriptionMonthly'
    OnlineBankingPayment = 'OnlineBankingPayment'
    OnlineBankingSubscription = 'OnlineBankingSubscription'
    OnlinePOSSale = 'OnlinePOSSale'
    OnlinePersonalCustAncillarys = 'OnlinePersonalCustAncillarys'
    OnlinePersonalCustService = 'OnlinePersonalCustService'
    OnlinePersonalCustOverlimits = 'OnlinePersonalCustOverlimits'
    OnlineReplacementCardReader = 'OnlineReplacementCardReader'
    OnlinePersonalCustSetUp = 'OnlinePersonalCustSetUp'
    OnlinePersonalCustTransaction = 'OnlinePersonalCustTransaction'
    OnlinePaymentinGBPtoUK = 'OnlinePaymentinGBPtoUK'
    OnlineUrgentPayment = 'OnlineUrgentPayment'
    OnlinePaymentinUSDtoUS = 'OnlinePaymentinUSDtoUS'
    OnlineBulkDirectDebSterling = 'OnlineBulkDirectDebSterling'
    ForeignChqSent = 'ForeignChqSent'
    ForeignChqSelf = 'ForeignChqSelf'
    ForeignChqEncashment = 'ForeignChqEncashment'
    ForeignFXInwardsCust = 'ForeignFXInwardsCust'
    ForeignFXTransfersROI = 'ForeignFXTransfersROI'
    ForeignFXForwardTrans = 'ForeignFXForwardTrans'
    ForeignFXTransfersBOI = 'ForeignFXTransfersBOI'
    ForeignExMaintenance = 'ForeignExMaintenance'
    ForeignFXInwardsNonCust = 'ForeignFXInwardsNonCust'
    ForeignFXOutwards = 'ForeignFXOutwards'
    ForeignPurchase = 'ForeignPurchase'
    ForeignStatusRep = 'ForeignStatusRep'
    ForeignChqDraft = 'ForeignChqDraft'
    ForeignChqCLess = 'ForeignChqCLess'
    ForeignChqMLess = 'ForeignChqMLess'
    ForeignChqOther = 'ForeignChqOther'
    ForeignChqMPlus = 'ForeignChqMPlus'
    ForeignChqCCC = 'ForeignChqCCC'
    ServiceCAccountFee = 'ServiceCAccountFee'
    ServiceCAccountFeeMonthly = 'ServiceCAccountFeeMonthly'
    ServiceCAccountFeeQuarterly = 'ServiceCAccountFeeQuarterly'
    ServiceCBalanceHandling = 'ServiceCBalanceHandling'
    ServiceCFixedTariff = 'ServiceCFixedTariff'
    ServiceCBusiDepAccBreakage = 'ServiceCBusiDepAccBreakage'
    ServiceCMonitorDaily = 'ServiceCMonitorDaily'
    ServiceCManagementFee = 'ServiceCManagementFee'
    ServiceCMinimumMonthlyFee = 'ServiceCMinimumMonthlyFee'
    ServiceCMonitorMonthly = 'ServiceCMonitorMonthly'
    ServiceCMonitorWeekly = 'ServiceCMonitorWeekly'
    ServiceCSecurityFee = 'ServiceCSecurityFee'
    ServiceCMT940AccountFirst = 'ServiceCMT940AccountFirst'
    ServiceCMT940AccountSubsequent = 'ServiceCMT940AccountSubsequent'
    ServiceCOther = 'ServiceCOther'
    CounterCoinHandling = 'CounterCoinHandling'
    CounterCashIn = 'CounterCashIn'
    CounterCashInNotUs = 'CounterCashInNotUs'
    CounterCashOut = 'CounterCashOut'
    CounterCashX = 'CounterCashX'
    CounterForeignCashMax = 'CounterForeignCashMax'
    CounterForeignNoteHandling = 'CounterForeignNoteHandling'
    CounterForeignCashOut = 'CounterForeignCashOut'
    CounterCashFeeRate = 'CounterCashFeeRate'
    CounterForeignCashOutTx = 'CounterForeignCashOutTx'
    CounterCounterLodgement = 'CounterCounterLodgement'
    CounterCashDropLodgement = 'CounterCashDropLodgement'
    CounterNotesLodged = 'CounterNotesLodged'
    CounterNotesOut = 'CounterNotesOut'
    CounterCashInOwn = 'CounterCashInOwn'
    CounterPaidTrans = 'CounterPaidTrans'
    CounterCashFeePercent = 'CounterCashFeePercent'


class FeeDetail1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeSubDetails_1: FeeSubDetails = Field(
        ..., alias='FeeSubDetails', description='Fee Sub Details'
    )
    FeeType_1: FeeType = Field(
        ..., alias='FeeType', description='A description of the Fee type'
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    Other: Optional[str] = Field(None, description='Describe other fee type')
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeeSubType(Enum):
    FutureMultipleTerms = 'FutureMultipleTerms'
    Promotional = 'Promotional'
    Regular = 'Regular'


class FeeDetail(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeDetail: FeeDetail1 = Field(..., description='Fee Detail')
    FeeSubType_1: FeeSubType = Field(
        ..., alias='FeeSubType', description='Fee Sub Type code'
    )


class Fees(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeDetails: List[FeeDetail] = Field(..., min_length=1)
    FeeHigherTier: Optional[int] = Field(
        None,
        description='Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range',
    )
    FeeLowerTier: Optional[int] = Field(
        None,
        description='Lower occurrence / range boundary e.g.. For returned cheques this could be 0, which means the first returned cheque fits into this range',
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeesAndCharge(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Fees_1: Fees = Field(..., alias='Fees', description='Fees')
    ProductState_1: ProductState = Field(
        ...,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )


class MobileWalletEnum(Enum):
    AndroidPay = 'AndroidPay'
    ApplePay = 'ApplePay'
    IssuerMobileApp = 'IssuerMobileApp'
    MobileBankingApp = 'MobileBankingApp'
    Other = 'Other'
    PayM = 'PayM'
    SamsungPay = 'SamsungPay'
    VodafoneWallet = 'VodafoneWallet'


class Brand2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    TrademarkID: constr(min_length=1, max_length=35) = Field(
        ...,
        description='The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted',
    )
    TrademarkIPOCode_1: TrademarkIPOCode = Field(
        ...,
        alias='TrademarkIPOCode',
        description='The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)',
    )


class ParentOrganisation2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BIC: Optional[constr(pattern=r'[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?')] = Field(
        None, description='The BIC from the organisation'
    )
    LEI: Optional[constr(pattern=r'^[A-Z0-9]{18,18}[0-9]{2,2}$')] = Field(
        None, description='The LEI ID of the organisation'
    )
    OrganisationName_1: OrganisationName = Field(
        ..., alias='OrganisationName', description='Organisation Name'
    )


class Organisation2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Brand: Brand2 = Field(..., description='Brand')
    ParentOrganisation: ParentOrganisation2 = Field(
        ..., description='Parent organisation'
    )


class FeeChargeNegotiableIndicator(Enum):
    No = 'No'
    Yes = 'Yes'


class FeeChargeApplicationFrequency(Enum):
    AcademicTerm = 'AcademicTerm'
    Daily = 'Daily'
    Weekly = 'Weekly'
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Half_Yearly = 'Half-Yearly'
    Yearly = 'Yearly'
    Overnight = 'Overnight'
    Other = 'Other'


class FeeChargeCalculationFrequency(Enum):
    AcademicTerm = 'AcademicTerm'
    Daily = 'Daily'
    Weekly = 'Weekly'
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Half_Yearly = 'Half-Yearly'
    Yearly = 'Yearly'
    Overnight = 'Overnight'
    Other = 'Other'


class FeeChargeOtherApplicationFrequency(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Code: Optional[constr(min_length=4, max_length=4)] = Field(
        None,
        description="Code mnemonic for 'Other' code set value applicable to specified attribute",
    )
    Description: Optional[str] = Field(
        None,
        description="Description for 'Other' code set value applicable to specified attribute",
    )
    Name: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description="Name of 'Other' code set value applicable to specified attribute",
    )


class FeeChargeOtherCalculationFrequency(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Code: Optional[constr(min_length=4, max_length=4)] = Field(
        None,
        description="Code mnemonic for 'Other' code set value applicable to specified attribute",
    )
    Description: Optional[str] = Field(
        None,
        description="Description for 'Other' code set value applicable to specified attribute",
    )
    Name: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description="Name of 'Other' code set value applicable to specified attribute",
    )


class FeeChargeOtherType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Code: Optional[constr(min_length=4, max_length=4)] = Field(
        None,
        description="Code mnemonic for 'Other' code set value applicable to specified attribute",
    )
    Description: Optional[str] = Field(
        None,
        description="Description for 'Other' code set value applicable to specified attribute",
    )
    Name: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description="Name of 'Other' code set value applicable to specified attribute",
    )


class FeeChargeRateOtherType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Code: Optional[constr(min_length=4, max_length=4)] = Field(
        None,
        description="Code mnemonic for 'Other' code set value applicable to specified attribute",
    )
    Description: Optional[str] = Field(
        None,
        description="Description for 'Other' code set value applicable to specified attribute",
    )
    Name: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description="Name of 'Other' code set value applicable to specified attribute",
    )


class FeeChargeRateType(Enum):
    Gross = 'Gross'
    Net = 'Net'
    Other = 'Other'


class FeeChargeType(Enum):
    Periodic = 'Periodic'
    Minimum = 'Minimum'
    Maximum = 'Maximum'
    Setup = 'Setup'
    Review = 'Review'
    Renewal = 'Renewal'
    MinimumSetup = 'MinimumSetup'
    MaximumSetup = 'MaximumSetup'
    Total = 'Total'
    Item = 'Item'
    EmergencyLending = 'EmergencyLending'
    Other = 'Other'


class FeesAndCharge1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeChargeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Charge applied to tier'
    )
    FeeChargeApplicationFrequency_1: Optional[FeeChargeApplicationFrequency] = Field(
        None,
        alias='FeeChargeApplicationFrequency',
        description='Frequency with which the rate, or amount is charged',
    )
    FeeChargeCalculationFrequency_1: Optional[FeeChargeCalculationFrequency] = Field(
        None,
        alias='FeeChargeCalculationFrequency',
        description='Frequency with which the rate, or amount is calculated',
    )
    FeeChargeOtherApplicationFrequency_1: Optional[
        FeeChargeOtherApplicationFrequency
    ] = Field(
        None, alias='FeeChargeOtherApplicationFrequency', description='Other Code Type'
    )
    FeeChargeOtherCalculationFrequency_1: Optional[
        FeeChargeOtherCalculationFrequency
    ] = Field(
        None, alias='FeeChargeOtherCalculationFrequency', description='Other Code Type'
    )
    FeeChargeOtherType_1: Optional[FeeChargeOtherType] = Field(
        None, alias='FeeChargeOtherType', description='Other Code Type'
    )
    FeeChargeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Fee charge rate applied to tier'
    )
    FeeChargeRateOtherType_1: Optional[FeeChargeRateOtherType] = Field(
        None, alias='FeeChargeRateOtherType', description='Other Code Type'
    )
    FeeChargeRateType_1: Optional[FeeChargeRateType] = Field(
        None, alias='FeeChargeRateType', description='Rate type other than EAR'
    )
    FeeChargeType_1: FeeChargeType = Field(
        ..., alias='FeeChargeType', description='Type of fee or charge'
    )


class OverdraftProductState(Enum):
    FutureMultipleTerms = 'FutureMultipleTerms'
    Promotional = 'Promotional'
    Regular = 'Regular'


class ArrangementOtherType(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Code: Optional[constr(min_length=4, max_length=4)] = Field(
        None,
        description="Code mnemonic for 'Other' code set value applicable to specified attribute",
    )
    Description: Optional[str] = Field(
        None,
        description="Description for 'Other' code set value applicable to specified attribute",
    )
    Name: Optional[constr(min_length=1, max_length=256)] = Field(
        None,
        description="Name of 'Other' code set value applicable to specified attribute",
    )


class ArrangementType(Enum):
    Unarranged = 'Unarranged'
    Arranged = 'Arranged'
    Other = 'Other'


class FeesAndCharge2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeChargeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Charge applied to tier'
    )
    FeeChargeApplicationFrequency_1: Optional[FeeChargeApplicationFrequency] = Field(
        None,
        alias='FeeChargeApplicationFrequency',
        description='Frequency with which the rate, or amount is charged',
    )
    FeeChargeCalculationFrequency_1: Optional[FeeChargeCalculationFrequency] = Field(
        None,
        alias='FeeChargeCalculationFrequency',
        description='Frequency with which the rate, or amount is calculated',
    )
    FeeChargeOtherApplicationFrequency_1: Optional[
        FeeChargeOtherApplicationFrequency
    ] = Field(
        None, alias='FeeChargeOtherApplicationFrequency', description='Other Code Type'
    )
    FeeChargeOtherCalculationFrequency_1: Optional[
        FeeChargeOtherCalculationFrequency
    ] = Field(
        None, alias='FeeChargeOtherCalculationFrequency', description='Other Code Type'
    )
    FeeChargeOtherType_1: Optional[FeeChargeOtherType] = Field(
        None, alias='FeeChargeOtherType', description='Other Code Type'
    )
    FeeChargeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Fee charge rate applied to tier'
    )
    FeeChargeRateOtherType_1: Optional[FeeChargeRateOtherType] = Field(
        None, alias='FeeChargeRateOtherType', description='Other Code Type'
    )
    FeeChargeRateType_1: Optional[FeeChargeRateType] = Field(
        None, alias='FeeChargeRateType', description='Rate type other than EAR'
    )
    FeeChargeType_1: FeeChargeType = Field(
        ..., alias='FeeChargeType', description='Type of fee or charge'
    )


class FeesAndCharge3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeChargeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Charge applied to tier'
    )
    FeeChargeApplicationFrequency_1: Optional[FeeChargeApplicationFrequency] = Field(
        None,
        alias='FeeChargeApplicationFrequency',
        description='Frequency with which the rate, or amount is charged',
    )
    FeeChargeCalculationFrequency_1: Optional[FeeChargeCalculationFrequency] = Field(
        None,
        alias='FeeChargeCalculationFrequency',
        description='Frequency with which the rate, or amount is calculated',
    )
    FeeChargeOtherApplicationFrequency_1: Optional[
        FeeChargeOtherApplicationFrequency
    ] = Field(
        None, alias='FeeChargeOtherApplicationFrequency', description='Other Code Type'
    )
    FeeChargeOtherCalculationFrequency_1: Optional[
        FeeChargeOtherCalculationFrequency
    ] = Field(
        None, alias='FeeChargeOtherCalculationFrequency', description='Other Code Type'
    )
    FeeChargeOtherType_1: Optional[FeeChargeOtherType] = Field(
        None, alias='FeeChargeOtherType', description='Other Code Type'
    )
    FeeChargeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Fee charge rate applied to tier'
    )
    FeeChargeRateOtherType_1: Optional[FeeChargeRateOtherType] = Field(
        None, alias='FeeChargeRateOtherType', description='Other Code Type'
    )
    FeeChargeRateType_1: Optional[FeeChargeRateType] = Field(
        None, alias='FeeChargeRateType', description='Rate type other than EAR'
    )
    FeeChargeType_1: FeeChargeType = Field(
        ..., alias='FeeChargeType', description='Type of fee or charge'
    )


class OverdraftTierBandItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    EAR: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='EAR of the Tier'
    )
    FeesAndCharges: Optional[List[FeesAndCharge3]] = None
    Notes: Optional[str] = Field(None, description='Notes on the Overdraft')
    TierBandIdentification: Optional[str] = Field(
        None, description='Identification of the tier or band'
    )
    TierValueMaximum: constr(min_length=1, max_length=15) = Field(
        ..., description='Maximum value of the tier'
    )
    TierValueMinimum: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Minimum value of the tier'
    )


class OverdraftTierBandSetItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ArrangementOtherType_1: Optional[ArrangementOtherType] = Field(
        None, alias='ArrangementOtherType', description='Other Code Type'
    )
    ArrangementType_1: ArrangementType = Field(
        ...,
        alias='ArrangementType',
        description='Defines the arrangement of the overdraft',
    )
    BufferAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Amount on overdraft that is prearranged'
    )
    CMADefinedIndicator: bool = Field(
        ...,
        description='describes that the tiers and bands are set by the CMA order, as opposed to be set by the banks',
    )
    EAR: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='EAR of the Overdraft Set'
    )
    FeesAndCharges: Optional[List[FeesAndCharge2]] = Field(
        None, description='Type of fee or charge'
    )
    Notes: Optional[str] = Field(None, description='Notes on the Overdraft')
    OverdraftTierBand: Optional[List[OverdraftTierBandItem]] = None
    TierBandSetIdentification: Optional[str] = Field(
        None, description='Identification of the set of tiers or bands'
    )


class OverdraftType(Enum):
    Committed = 'Committed'
    OnDemand = 'OnDemand'


class OverdraftItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeChargeNegotiableIndicator_1: Optional[FeeChargeNegotiableIndicator] = Field(
        None,
        alias='FeeChargeNegotiableIndicator',
        description='Fee Charge negotiable Indicator',
    )
    FeesAndCharges: Optional[List[FeesAndCharge1]] = None
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    MaximumMonthlyOverdraftCharge: Optional[
        constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')
    ] = Field(
        None, description='Maximum Monthly Charge (MMC) for Overdraft fee and charges.'
    )
    Notes: Optional[str] = Field(None, description='Notes on the overdraft')
    OverdraftProductState_1: Optional[OverdraftProductState] = Field(
        None,
        alias='OverdraftProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )
    OverdraftTierBandSet: Optional[List[OverdraftTierBandSetItem]] = Field(
        None, description='Overdraft Tier Band Set'
    )
    OverdraftType_1: Optional[OverdraftType] = Field(
        None,
        alias='OverdraftType',
        description='Defines if the overdraft facility is committed ',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')
    Term: Optional[str] = Field(
        None, description='The duration of the overdraft, if it is non permanent'
    )


class ProductSegmentEnum(Enum):
    Basic = 'Basic'
    Business = 'Business'
    General = 'General'
    Graduate = 'Graduate'
    International = 'International'
    Packaged = 'Packaged'
    Personal = 'Personal'
    Premium = 'Premium'
    Reward = 'Reward'
    SME = 'SME'
    Student = 'Student'
    YoungAdult = 'YoungAdult'
    Youth = 'Youth'


class ProductType(Enum):
    BCA = 'BCA'


class Datum2(BaseModel):
    AccessChannels: List[AccessChannel] = Field(
        ...,
        description='Ways to interact with the bank when managing account',
        min_length=1,
    )
    Benefits_1: Benefits = Field(..., alias='Benefits', description='Benefit')
    CAPricing: List[CAPricingItem] = Field(..., min_length=1)
    CardNotes: Optional[str] = Field(
        None, description='Optional additional notes to supplement the card details'
    )
    CardType: List[CardTypeEnum] = Field(
        ..., description='Card Type available', min_length=1
    )
    CardWithdrawalLimit: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ...,
        description='The daily Limit that a customer can get via the ATM. This describes the default limit rather than the maximum',
    )
    ChequeBookAvailable: bool = Field(..., description='Can a chequebook be issued')
    Contactless: bool = Field(
        ..., description='Does the card issued have contactless facility'
    )
    CreditInterest_1: CreditInterest = Field(
        ..., alias='CreditInterest', description='Credit Interest'
    )
    CreditScoringPartOfAccountOpeningForGettingAnAccount: bool = Field(
        ...,
        description='Indicates whether a credit check performed on an inquiry to open an account is submitted',
    )
    CreditScoringPartOfAccountOpeningForIDVerification: Optional[bool] = Field(
        None,
        description='Indicates whether a credit check is used to check the address of a potential new account holder',
    )
    CreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScore: Optional[
        List[
            CreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScoreEnum
        ]
    ] = None
    CreditScoringPartOfAccountOpeningIDVerificationText: Optional[List[str]] = Field(
        None, description='Details on the specific credit scoring'
    )
    CreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScore: Optional[
        List[CreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScoreEnum]
    ] = Field(None, description='Describes the type of credit scoring')
    CreditScoringPartOfAccountOpeningText: Optional[str] = Field(
        None, description='Details on the specific credit scoring'
    )
    Currency: List[CurrencyItem] = Field(
        ...,
        description='Currency of the Account. Default to GBP at present',
        min_length=1,
    )
    Eligibility_1: Eligibility = Field(
        ..., alias='Eligibility', description='Eligibility'
    )
    Feature: Optional[List[FeatureItem]] = None
    FeesAndCharges: List[FeesAndCharge] = Field(..., min_length=1)
    InternationalPaymentsSupported: bool = Field(
        ..., description='Indicates that the account supports international payments'
    )
    MaximumMonthlyCharge: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='The maximum Relevant Charges that could accrue'
    )
    MobileWallet: Optional[List[MobileWalletEnum]] = Field(
        None,
        description='Mobile wallet supported by this product. A mobile wallet being any electronic device that allows an individual to make electronic commerce transactions',
    )
    Organisation: Organisation2 = Field(..., description='Organisation')
    Overdraft: Optional[List[OverdraftItem]] = None
    OverdraftOffered: bool = Field(
        ..., description='Indicates whether an overdraft offered for this account'
    )
    ProductDescription: str = Field(
        ...,
        description='Description of the product provided by the parent organisation',
    )
    ProductIdentifier: str = Field(
        ...,
        description='Identifier within the parent organisation for the product. Must be unique in the organisation',
    )
    ProductName: Optional[str] = Field(
        None,
        description='The name of the product used for marketing purposes from a customer perspective. i.e. what the customer would recognise',
    )
    ProductSegment: List[ProductSegmentEnum] = Field(..., min_length=1)
    ProductType_1: ProductType = Field(
        ...,
        alias='ProductType',
        description='Descriptive code for the product category',
    )
    ProductURL: List[AnyUrl] = Field(
        ...,
        description='URL provided by the organisation which redirects to the product (on live products only). There might be more than one product at a given URL',
    )
    TsandCs: List[str] = Field(
        ...,
        description='URL provided by the parent organisation which redirects to the current T&Cs',
        min_length=1,
    )


class Meta2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Agreement_1: Agreement = Field(..., alias='Agreement')
    LastUpdated: datetime
    License_1: License = Field(..., alias='License', description='Open Banking License')
    TermsOfUse_1: TermsOfUse = Field(
        ..., alias='TermsOfUse', description='Open Banking Terms of Use'
    )
    TotalResults: int


class BusinessCurrentAccountsGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[Datum2]
    meta: Meta2 = Field(..., title='Meta data')


class Description10(Enum):
    You_have_sent_a_request_which_could_not_be_understood_ = (
        'You have sent a request which could not be understood.'
    )


class Status10(Enum):
    field_400 = '400'


class Title10(Enum):
    Bad_request = 'Bad request'


class BusinessCurrentAccountsGetResponse1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description10
    status: Status10
    title: Title10


class Description11(Enum):
    Your_client_has_failed_to_submit_a_request__and_a_timeout_has_occurred_ = (
        'Your client has failed to submit a request, and a timeout has occurred.'
    )


class Status11(Enum):
    field_408 = '408'


class Title11(Enum):
    Client_timeout = 'Client timeout'


class BusinessCurrentAccountsGetResponse2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description11
    status: Status11
    title: Title11


class Description12(Enum):
    You_have_requested_this_resource_too_often__Slow_down_ = (
        'You have requested this resource too often. Slow down.'
    )


class Status12(Enum):
    field_429 = '429'


class Title12(Enum):
    Too_many_requests = 'Too many requests'


class BusinessCurrentAccountsGetResponse3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description12
    status: Status12
    title: Title12


class Description13(Enum):
    An_error_occurred_on_the_server__No_further_information_is_available_ = (
        'An error occurred on the server. No further information is available.'
    )


class Status13(Enum):
    field_500 = '500'


class Title13(Enum):
    Internal_server_error = 'Internal server error'


class BusinessCurrentAccountsGetResponse4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description13
    status: Status13
    title: Title13


class Description14(Enum):
    The_service_is_temporarily_unavailable_ = 'The service is temporarily unavailable.'


class Status14(Enum):
    field_503 = '503'


class Title14(Enum):
    Service_temporarily_unavailable = 'Service temporarily unavailable'


class BusinessCurrentAccountsGetResponse5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description14
    status: Status14
    title: Title14


class BusinessCurrentAccountsGetResponse6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='Further details describing the error')
    status: str = Field(..., description='This corresponds to the HTTP status code')
    title: str = Field(..., description='A short title of the type of error')


class BusinessCurrentAccountsHeadResponse(BaseModel):
    pass


class BenefitDetailItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDescription: Optional[str] = Field(
        None, description='A textual explanation of what the benefit is'
    )
    BenefitID: Optional[str] = Field(
        None, description='Unique benefit identifier per organisation'
    )
    BenefitName: Optional[str] = Field(None, description='The name of the benefit')
    BenefitType: Optional[str] = Field(
        None, description='Type that represents the nature of the benefit'
    )
    BenefitValue: Optional[str] = Field(
        None,
        description='The value or values permissible for a specific benefit for an individual product representing a product characteristic',
    )
    Counter: Optional[int] = Field(
        None, description='Counter for the criteria (e.g. number of DD)'
    )
    CriteriaType: Optional[List[CriteriaTypeEnum]] = None
    DefaultToAccounts: Optional[bool] = Field(
        None, description='Is the benefit part of the default account'
    )
    MaximumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Maximum amount for the criteria'
    )
    MinimumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum amount for the criteria'
    )
    PromotionEndDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the end date is when the benefit is no longer applicable',
    )
    PromotionStartDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the start date is when the benefit comes into effect',
    )


class BenefitItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDetail: Optional[List[BenefitDetailItem1]] = None
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date in days',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class BenefitGroupItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitItem: BenefitItem1 = Field(..., description='Benefit Item')
    BenefitSubType_1: Optional[BenefitSubType] = Field(
        None, alias='BenefitSubType', description='Benefit Subtype Code'
    )


class Benefits1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Benefit: bool = Field(
        ..., description='Describe  one or more benefits if they exist'
    )
    BenefitGroup: Optional[List[BenefitGroupItem1]] = None


class CCSubType(Enum):
    FutureMultipleTerms = 'FutureMultipleTerms'
    Promotional = 'Promotional'
    Regular = 'Regular'


class BalanceTransferInterestRatePeriod(Enum):
    Annual = 'Annual'
    Monthly = 'Monthly'


class CardScheme(Enum):
    Cashcard = 'Cashcard'
    CreditMastercard = 'CreditMastercard'
    CreditVisa = 'CreditVisa'


class RepaymentFrequency(Enum):
    Daily = 'Daily'
    Flexible = 'Flexible'
    Fortnightly = 'Fortnightly'
    HalfYearly = 'HalfYearly'
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Weekly = 'Weekly'
    Yearly = 'Yearly'


class CommercialCreditCardItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    APRRate: constr(pattern=r'^-?\d{1,3}\.\d{1,4}$') = Field(
        ..., description='Annual Percentage Rate'
    )
    AbilityToSetIndividualLimits: Optional[bool] = Field(
        None,
        description='The ability to set separate limts on different cards in one account',
    )
    AccessToOnlineDataReportingTool: bool = Field(
        ...,
        description='Describes whether the account have access to an online tool for reprting on expenditure',
    )
    AllocationofRepayment: Optional[str] = Field(
        None, description='Allocation rules for repayment'
    )
    AnnualAccountFeeType: Optional[str] = Field(
        None,
        description='Details on annual account fee, such as non payable when there is a turnover above a certain sum',
    )
    AnnualFeeAmount: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Standard fee on the card'
    )
    BalanceTransferInterestRatePeriod_1: Optional[BalanceTransferInterestRatePeriod] = (
        Field(
            None,
            alias='BalanceTransferInterestRatePeriod',
            description='The period used to define the specific interest rate for balance transfers',
        )
    )
    BalanceTransferRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Balance transfer rate'
    )
    CardScheme_1: CardScheme = Field(
        ..., alias='CardScheme', description='Card Scheme Code'
    )
    CashAdvanceRate: constr(pattern=r'^-?\d{1,3}\.\d{1,4}$') = Field(
        ..., description='Cash advance rate'
    )
    CashWithdrawalsAllowed: bool = Field(
        ..., description='Describes whether cash withdrawals are allowed'
    )
    CashbackPercent: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Percent of cashback on amount spend'
    )
    ChequeFeePercent: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Percentage fee on convenience cheques'
    )
    ConvenienceCheque: bool = Field(
        ..., description='Describes whether the card account allow convenience cheques'
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    DaysInterestFreeCreditIfPaymentFull: int = Field(
        ...,
        description='Describes how many interest free days are given if the card is fully paid at each term',
    )
    ExchangeRateAdjustment: constr(pattern=r'^-?\d{1,3}\.\d{1,4}$') = Field(
        ...,
        description='The margin added, by certain card issuers, to the scheme rate in order to arrive at the exchange rate qouted as the reference exchange rate to the cardholder',
    )
    FeesOnCheque: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Percentage fee on a convenince cheques'
    )
    ForeignCashFee: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None,
        description='Additional card fee applied to sterling cash withdrawal made abroad',
    )
    ForeignCashFeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None,
        description='Additional card fee rate applied to sterling cash withdrawal made abroad',
    )
    ForeignPurchaseFee: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None,
        description='Additional card fee applied to sterling retail transactions made abroad',
    )
    ForeignPurchaseFeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None,
        description='Additional card fee rate applied to sterling retail transactions made abroad',
    )
    IssuingEmergencyCardsFees: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Amount payable for issuing an emergency card'
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    MaximumNumberOfCardsPermitted: Optional[int] = Field(
        None, description='The maximum numbers of cards per account'
    )
    MinimumCreditLimit: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Minimum £500, maximum subject to status'
    )
    MinimumLendingAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='The minimum lending available'
    )
    MinimumRepaymentAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum repayment amount'
    )
    MinimumRepaymentPercentage: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = (
        Field(None, description='Minimum repayment as percentage')
    )
    NonSterlingCashFee: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None,
        description='An additional fee applied to certain card cash withdrawals. This fee also applies to cash near fees such as gambling',
    )
    NonSterlingCashFeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None,
        description='An additional fee rate applied to certain card cash withdrawals. This fee also applies to cash near fees such as gambling',
    )
    NonSterlingPurchaseFee: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None,
        description='An additional fee applied to certain card retail transactions',
    )
    NonSterlingPurchaseFeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = (
        Field(
            None,
            description='An additional fee rate applied to certain card retail transactions',
        )
    )
    NonSterlingTransactionFee: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(None, description='A fee applied to all non-Sterling card transactions')
    )
    NonSterlingTransactionFeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = (
        Field(
            None, description='A fee rate applied to all non-Sterling card transactions'
        )
    )
    OverLimitFee: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee applicable if the card was credited over its limit'
    )
    PaymentDaysAfterStatement: int = Field(
        ..., description='How many days after statement is the payment expected'
    )
    PaymentSchemeExchangeFee: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(
            None,
            description='Any payment network fee applied to some or all non-sterling transactions that the card issuer recover directly from the cardholder',
        )
    )
    PaymentSchemeExchangeFeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = (
        Field(
            None,
            description='Any payment network fee rate applied to some or all non-sterling transactions that the card issuer recover directly from the cardholder',
        )
    )
    PaymentSchemeExchangeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = (
        Field(
            None,
            description='The base exchange rate used in settlement of the transaction between issuer and scheme',
        )
    )
    PurchaseRate: constr(pattern=r'^-?\d{1,3}\.\d{1,4}$') = Field(
        ..., description='Purchase rate'
    )
    RepaymentFrequency_1: RepaymentFrequency = Field(
        ..., alias='RepaymentFrequency', description='Repayment frequency'
    )
    RepaymentNotes: Optional[str] = Field(None, description='Additional notes')
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StatementAtAccountLevel: bool = Field(
        ..., description='Describes whether there is a statement at account level'
    )
    StatementAtPersonalLevel: bool = Field(
        ..., description='Describes whether there is a statement at card level'
    )
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class Details(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CCSubType_1: CCSubType = Field(
        ..., alias='CCSubType', description='CCC Subtype Code'
    )
    CommercialCreditCardItem_1: CommercialCreditCardItem = Field(
        ...,
        alias='CommercialCreditCardItem',
        description='Commercial Credit Card Item ',
    )


class Eligibility1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    AgeRestricted: bool = Field(
        ..., description="Indicates a customer's age is part of eligibility criteria"
    )
    AnnualBusinessTurnover: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Annual Business Turnover'
    )
    AnnualBusinessTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Annual Business Turnover Currency'
    )
    Description: str = Field(..., description='One paragraph detailing the eligibility')
    EligibilityName: Optional[str] = Field(
        None,
        description='Free text description, denotes non standard eligibilities not included in the code list',
    )
    EligibilityNotes: Optional[str] = Field(
        None,
        description='Optional additional notes to supplement the eligibility conditions. Only used for very specific conditions',
    )
    EligibilityType_1: Optional[EligibilityType] = Field(
        None, alias='EligibilityType', description='Eligibility type'
    )
    IncomeCondition: Optional[str] = Field(
        None,
        description='Stipulates any particular definition of income that applies to the income eligibility and/or method by which income must paid into the account (eg Salary DD)',
    )
    IncomeTurnoverRelated: bool = Field(
        ..., description='Indicates if eligibility linked to income'
    )
    MarketingEligibility: Optional[List[MarketingEligibilityEnum]] = None
    MaxNumberOfAccounts: Optional[str] = Field(
        None, description='Maximum number of the same prodcut the customer may hold'
    )
    MaximumAge: Optional[int] = Field(
        None, description='Maximum age, in years, allowed to hold the account'
    )
    MaximumAgeToOpen: Optional[int] = Field(
        None, description='Maximum age, in years, to open an account'
    )
    MaximumOpeningAmount: Optional[bool] = Field(
        None, description='A maximum amount to be deposited at opening'
    )
    MinIncomeTurnoverPaidIntoAccount: Optional[int] = Field(
        None, description='Minimum Income Amount required to paid into the account'
    )
    MinimumAge: Optional[int] = Field(
        None, description='Minimum age, in years, required to hold an account'
    )
    MinimumDeposit: Optional[bool] = Field(
        None, description='A minimum deposit required to hold this account'
    )
    MinimumIncomeFrequency_1: Optional[MinimumIncomeFrequency] = Field(
        None,
        alias='MinimumIncomeFrequency',
        description='The frequency that the minimum mentioned before is deposited in the account. Yearly is very important for premium accounts',
    )
    MinimumIncomeTurnoverAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(
            None, description='Minimum income / Turnover required to hold the product'
        )
    )
    MinimumIncomeTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum income / Turnover Currency'
    )
    MinimumOperatingBalance: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Operating Balance'
    )
    MinimumOperatingBalanceCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum Operating Balance currency'
    )
    MinimumOperatingBalanceExists: Optional[bool] = Field(
        None, description='Is there a Minimum Operating Balance?'
    )
    OpeningDepositMaximumAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(None, description='Maximum Amount to be depositing at opening')
    )
    OpeningDepositMaximumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OpeningDepositMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Amount to be held on account'
    )
    OpeningDepositMinimumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OtherFinancialHoldingRequired: bool = Field(
        ...,
        description='Indicates that it is necessary to hold another product with the bank in order to be eligible for this product or feature',
    )
    PreviousBankruptcy: bool = Field(
        ...,
        description='Describes if a previous bankruptcy / insolvency disqualfies for this account Details in ELI-280',
    )
    ResidencyRestricted: bool = Field(
        ...,
        description="Indicates a customer's residency forms part of the eligibility criteria",
    )
    ResidencyRestrictedRegion_1: Optional[ResidencyRestrictedRegion] = Field(
        None,
        alias='ResidencyRestrictedRegion',
        description='Indicates a customer must be current resident of a geographic area/country',
    )
    SingleJointIncome_1: Optional[SingleJointIncome] = Field(
        None,
        alias='SingleJointIncome',
        description='Minimum Income Source. For certain products a minimum income is required. This can be mandated as to the single income or to a joint income. This field describes this',
    )
    ThirdSectorOrganisations: bool = Field(
        ...,
        description='Is the product available to operate as a Clubs or Societies account?',
    )


class Brand3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    TrademarkID: constr(min_length=1, max_length=35) = Field(
        ...,
        description='The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted',
    )
    TrademarkIPOCode_1: TrademarkIPOCode = Field(
        ...,
        alias='TrademarkIPOCode',
        description='The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)',
    )


class ParentOrganisation3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BIC: Optional[constr(pattern=r'[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?')] = Field(
        None, description='The BIC from the organisation'
    )
    LEI: Optional[constr(pattern=r'^[A-Z0-9]{18,18}[0-9]{2,2}$')] = Field(
        None, description='The LEI ID of the organisation'
    )
    OrganisationName_1: OrganisationName = Field(
        ..., alias='OrganisationName', description='Organisation Name'
    )


class Organisation3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Brand: Brand3 = Field(..., description='Brand')
    ParentOrganisation: ParentOrganisation3 = Field(
        ..., description='Parent organisation'
    )


class ProductSegmentEnum1(Enum):
    Cashback = 'Cashback'
    Corporate = 'Corporate'
    General = 'General'
    Reward = 'Reward'
    SME = 'SME'


class ProductType1(Enum):
    CommercialCreditCards = 'CommercialCreditCards'


class Datum3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Benefits: Benefits1 = Field(..., description='Benefit')
    Description: str = Field(..., description='Product description')
    Details_1: Details = Field(
        ..., alias='Details', description='Commercial Credit Card Group '
    )
    Eligibility: Eligibility1 = Field(..., description='Eligibility')
    KeyFeatures: str = Field(..., description='Product key features')
    Organisation: Organisation3 = Field(..., description='Organisation')
    OtherKeyFeatures: Optional[str] = Field(
        None, description='Additional Features of the card'
    )
    PaymentHoliday: bool = Field(
        ..., description='Indicates whether a payment holiday is possible'
    )
    PaymentHolidayDescription: Optional[str] = Field(
        None, description='Detailed description on the payment holiday if available'
    )
    ProductIdentifier: str = Field(
        ...,
        description='Identifier within the parent organisation for the product. Must be unique in the organisation',
    )
    ProductName: str = Field(..., description='Name of the Commercial Credit Card')
    ProductSegment: Optional[List[ProductSegmentEnum1]] = Field(
        None,
        description='Marketing or industry segment that the product is designed for',
    )
    ProductType: ProductType1 = Field(
        ..., description='Descriptive code for the product category'
    )
    ProductURL: List[AnyUrl] = Field(
        ...,
        description='URL provided by the organisation which redirects to the product (on live products only). There might be more than one product at a given URL',
    )
    TsandCs: List[str] = Field(
        ...,
        description='URL provided by the parent organisation which redirects to the current T&Cs. Only applies on live products',
        min_length=1,
    )


class Meta3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Agreement_1: Agreement = Field(..., alias='Agreement')
    LastUpdated: datetime
    License_1: License = Field(..., alias='License', description='Open Banking License')
    TermsOfUse_1: TermsOfUse = Field(
        ..., alias='TermsOfUse', description='Open Banking Terms of Use'
    )
    TotalResults: int


class CommercialCreditCardsGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[Datum3]
    meta: Meta3 = Field(..., title='Meta data')


class Description15(Enum):
    You_have_sent_a_request_which_could_not_be_understood_ = (
        'You have sent a request which could not be understood.'
    )


class Status15(Enum):
    field_400 = '400'


class Title15(Enum):
    Bad_request = 'Bad request'


class CommercialCreditCardsGetResponse1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description15
    status: Status15
    title: Title15


class Description16(Enum):
    Your_client_has_failed_to_submit_a_request__and_a_timeout_has_occurred_ = (
        'Your client has failed to submit a request, and a timeout has occurred.'
    )


class Status16(Enum):
    field_408 = '408'


class Title16(Enum):
    Client_timeout = 'Client timeout'


class CommercialCreditCardsGetResponse2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description16
    status: Status16
    title: Title16


class Description17(Enum):
    You_have_requested_this_resource_too_often__Slow_down_ = (
        'You have requested this resource too often. Slow down.'
    )


class Status17(Enum):
    field_429 = '429'


class Title17(Enum):
    Too_many_requests = 'Too many requests'


class CommercialCreditCardsGetResponse3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description17
    status: Status17
    title: Title17


class Description18(Enum):
    An_error_occurred_on_the_server__No_further_information_is_available_ = (
        'An error occurred on the server. No further information is available.'
    )


class Status18(Enum):
    field_500 = '500'


class Title18(Enum):
    Internal_server_error = 'Internal server error'


class CommercialCreditCardsGetResponse4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description18
    status: Status18
    title: Title18


class Description19(Enum):
    The_service_is_temporarily_unavailable_ = 'The service is temporarily unavailable.'


class Status19(Enum):
    field_503 = '503'


class Title19(Enum):
    Service_temporarily_unavailable = 'Service temporarily unavailable'


class CommercialCreditCardsGetResponse5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description19
    status: Status19
    title: Title19


class CommercialCreditCardsGetResponse6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='Further details describing the error')
    status: str = Field(..., description='This corresponds to the HTTP status code')
    title: str = Field(..., description='A short title of the type of error')


class CommercialCreditCardsHeadResponse(BaseModel):
    pass


class BenefitDetailItem2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDescription: Optional[str] = Field(
        None, description='A textual explanation of what the benefit is'
    )
    BenefitID: Optional[str] = Field(
        None, description='Unique benefit identifier per organisation'
    )
    BenefitName: Optional[str] = Field(None, description='The name of the benefit')
    BenefitType: Optional[str] = Field(
        None, description='Type that represents the nature of the benefit'
    )
    BenefitValue: Optional[str] = Field(
        None,
        description='The value or values permissible for a specific benefit for an individual product representing a product characteristic',
    )
    Counter: Optional[int] = Field(
        None, description='Counter for the criteria (e.g. number of DD)'
    )
    CriteriaType: Optional[List[CriteriaTypeEnum]] = None
    DefaultToAccounts: Optional[bool] = Field(
        None, description='Is the benefit part of the default account'
    )
    MaximumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Maximum amount for the criteria'
    )
    MinimumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum amount for the criteria'
    )
    PromotionEndDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the end date is when the benefit is no longer applicable',
    )
    PromotionStartDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the start date is when the benefit comes into effect',
    )


class BenefitItem2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDetail: Optional[List[BenefitDetailItem2]] = None
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date in days',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class BenefitGroupItem2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitItem: BenefitItem2 = Field(..., description='Benefit Item')
    BenefitSubType_1: Optional[BenefitSubType] = Field(
        None, alias='BenefitSubType', description='Benefit Subtype Code'
    )


class Benefits2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Benefit: bool = Field(
        ..., description='Describe  one or more benefits if they exist'
    )
    BenefitGroup: Optional[List[BenefitGroupItem2]] = None


class CAPricingItem3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    ExchangeRateAdjustment: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None,
        description='The margin added, by certain card issuers, to the scheme rate in order to arrive at the exchange rate qouted as the reference exchange rate to the cardholder',
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class CAPricingItem2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CAPricingItem: CAPricingItem3 = Field(..., description='Card Pricing')
    ProductState_1: ProductState = Field(
        ...,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )


class InterestTier1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    APRAERRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='AER or APR Rate for comparison'
    )
    DailyChargeForMaximum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Special charge on tiered overdraft'
    )
    DailyChargeForMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Special charge on tiered overdraft'
    )
    InterestTier: Optional[str] = Field(None, description='Identifier for the tier')
    Rate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Rate being paid by the bank (gross)'
    )
    RateComparisonType_1: Optional[RateComparisonType] = Field(
        None, alias='RateComparisonType', description='Rate Comparison Type'
    )
    TierValueMaximum: Optional[constr(min_length=1, max_length=15)] = Field(
        None, description='Max Value of interst tier'
    )
    TierValueMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Lower value of interest tier'
    )


class CreditInterestItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CalculationFrequency_1: Optional[CalculationFrequency] = Field(
        None,
        alias='CalculationFrequency',
        description='How often is interest applied to account',
    )
    CalculationMethod_1: Optional[CalculationMethod] = Field(
        None, alias='CalculationMethod', description='Method for interest calculation'
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    EndDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If interest is charged on a specific date range as end date (often used for promotion)',
    )
    FixedInterestLength: Optional[int] = Field(
        None, description='Fixed interest length in days'
    )
    InterestNotes: Optional[str] = Field(
        None, description='Additional notes to supplement the interest details'
    )
    InterestRateType_1: Optional[InterestRateType] = Field(
        None, alias='InterestRateType', description='Credit Interest Payment Rate Type'
    )
    InterestTiers: Optional[List[InterestTier1]] = None
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    PaymentMethod_1: Optional[PaymentMethod] = Field(
        None, alias='PaymentMethod', description='Credit Interest Payment Method Code'
    )
    StartDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If interest is charged on a specific date range as start date (often used for promotion)',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class CreditInterestGroupItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CreditInterestItem: CreditInterestItem1 = Field(
        ..., description='Credit Interest item'
    )
    InterestTierSubType_1: Optional[InterestTierSubType] = Field(
        None,
        alias='InterestTierSubType',
        description='Describes if the offering is promotional, regular or a description of a future state',
    )


class CreditInterest1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CreditCharged: bool = Field(
        ...,
        description='Is credit paid to the account. The answer will be the condition of all other fields to be filled',
    )
    CreditInterestGroup: Optional[List[CreditInterestGroupItem1]] = None


class Eligibility2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    AgeRestricted: bool = Field(
        ..., description="Indicates a customer's age is part of eligibility criteria"
    )
    AnnualBusinessTurnover: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Annual Business Turnover'
    )
    AnnualBusinessTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Annual Business Turnover Currency'
    )
    Description: str = Field(..., description='One paragraph detailing the eligibility')
    EligibilityName: Optional[str] = Field(
        None,
        description='Free text description, denotes non standard eligibilities not included in the code list',
    )
    EligibilityNotes: Optional[str] = Field(
        None,
        description='Optional additional notes to supplement the eligibility conditions. Only used for very specific conditions',
    )
    EligibilityType_1: Optional[EligibilityType] = Field(
        None, alias='EligibilityType', description='Eligibility type'
    )
    IncomeCondition: Optional[str] = Field(
        None,
        description='Stipulates any particular definition of income that applies to the income eligibility and/or method by which income must paid into the account (eg Salary DD)',
    )
    IncomeTurnoverRelated: bool = Field(
        ..., description='Indicates if eligibility linked to income'
    )
    MarketingEligibility: Optional[List[MarketingEligibilityEnum]] = None
    MaxNumberOfAccounts: Optional[str] = Field(
        None, description='Maximum number of the same prodcut the customer may hold'
    )
    MaximumAge: Optional[int] = Field(
        None, description='Maximum age, in years, allowed to hold the account'
    )
    MaximumAgeToOpen: Optional[int] = Field(
        None, description='Maximum age, in years, to open an account'
    )
    MaximumOpeningAmount: Optional[bool] = Field(
        None, description='A maximum amount to be deposited at opening'
    )
    MinIncomeTurnoverPaidIntoAccount: Optional[int] = Field(
        None, description='Minimum Income Amount required to paid into the account'
    )
    MinimumAge: Optional[int] = Field(
        None, description='Minimum age, in years, required to hold an account'
    )
    MinimumDeposit: Optional[bool] = Field(
        None, description='A minimum deposit required to hold this account'
    )
    MinimumIncomeFrequency_1: Optional[MinimumIncomeFrequency] = Field(
        None,
        alias='MinimumIncomeFrequency',
        description='The frequency that the minimum mentioned before is deposited in the account. Yearly is very important for premium accounts',
    )
    MinimumIncomeTurnoverAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(
            None, description='Minimum income / Turnover required to hold the product'
        )
    )
    MinimumIncomeTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum income / Turnover Currency'
    )
    MinimumOperatingBalance: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Operating Balance'
    )
    MinimumOperatingBalanceCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum Operating Balance currency'
    )
    MinimumOperatingBalanceExists: Optional[bool] = Field(
        None, description='Is there a Minimum Operating Balance?'
    )
    OpeningDepositMaximumAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(None, description='Maximum Amount to be depositing at opening')
    )
    OpeningDepositMaximumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OpeningDepositMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Amount to be held on account'
    )
    OpeningDepositMinimumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OtherFinancialHoldingRequired: bool = Field(
        ...,
        description='Indicates that it is necessary to hold another product with the bank in order to be eligible for this product or feature',
    )
    PreviousBankruptcy: bool = Field(
        ...,
        description='Describes if a previous bankruptcy / insolvency disqualfies for this account Details in ELI-280',
    )
    ResidencyRestricted: bool = Field(
        ...,
        description="Indicates a customer's residency forms part of the eligibility criteria",
    )
    ResidencyRestrictedRegion_1: Optional[ResidencyRestrictedRegion] = Field(
        None,
        alias='ResidencyRestrictedRegion',
        description='Indicates a customer must be current resident of a geographic area/country',
    )
    SingleJointIncome_1: Optional[SingleJointIncome] = Field(
        None,
        alias='SingleJointIncome',
        description='Minimum Income Source. For certain products a minimum income is required. This can be mandated as to the single income or to a joint income. This field describes this',
    )
    ThirdSectorOrganisations: bool = Field(
        ...,
        description='Is the product available to operate as a Clubs or Societies account?',
    )


class FeatureDetail1(BaseModel):
    CriteriaType: Optional[str] = Field(
        None,
        description='Criteria that is required in order to be eligible for the feature',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeatureDescription: Optional[str] = Field(
        None, description='A textual explanation of what the feature'
    )
    FeatureName: Optional[str] = Field(None, description='The name of the feature')
    FeatureSubType_1: Optional[FeatureSubType] = Field(
        None, alias='FeatureSubType', description=''
    )
    FeatureType: Optional[str] = Field(
        None, description='Type that represents the nature of the feature'
    )
    FeatureValue: Optional[str] = Field(
        None,
        description='The value or values permissible for a specific feature for an individual product representing a product characteristic',
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeatureItem1(BaseModel):
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    ExistingFeature: bool = Field(
        ..., description='Indicates whether the account has any feature'
    )
    FeatureDetails: Optional[List[FeatureDetail1]] = Field(
        None, description='Feature details'
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    ProductState_1: Optional[ProductState] = Field(
        None,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeeSubDetails1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeFrequency_1: FeeFrequency = Field(
        ..., alias='FeeFrequency', description='Triggering frequency of the fee'
    )
    FeeHigherTier: Optional[int] = Field(
        None,
        description='Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range',
    )
    FeeLowerTier: Optional[int] = Field(
        None,
        description='Lower occurrence / range boundary e.g. For returned cheques this could be 0, which means the first returned cheque fits into this range',
    )
    FeeMax: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeMin: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='% Rate'
    )
    FeesAndChargesNotes: Optional[str] = Field(
        None, description='Supplementary information for fees and charges'
    )
    Negotiable: bool = Field(
        ...,
        description='Indicates that this Fee Rate or Fee Amount is negotiable based on risk or other factor',
    )
    RepresentativeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Representative Rate'
    )


class FeeDetail3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeSubDetails: FeeSubDetails1 = Field(..., description='Fee Sub Details')
    FeeType_1: FeeType = Field(
        ..., alias='FeeType', description='A description of the Fee type'
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    Other: Optional[str] = Field(None, description='Describe other fee type')
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeeDetail2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeDetail: FeeDetail3 = Field(..., description='Fee Detail')
    FeeSubType_1: FeeSubType = Field(
        ..., alias='FeeSubType', description='Fee Sub Type code'
    )


class Fees1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeDetails: List[FeeDetail2] = Field(..., min_length=1)
    FeeHigherTier: Optional[int] = Field(
        None,
        description='Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range',
    )
    FeeLowerTier: Optional[int] = Field(
        None,
        description='Lower occurrence / range boundary e.g.. For returned cheques this could be 0, which means the first returned cheque fits into this range',
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeesAndCharge4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Fees: Fees1 = Field(..., description='Fees')
    ProductState_1: ProductState = Field(
        ...,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )


class Brand4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    TrademarkID: constr(min_length=1, max_length=35) = Field(
        ...,
        description='The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted',
    )
    TrademarkIPOCode_1: TrademarkIPOCode = Field(
        ...,
        alias='TrademarkIPOCode',
        description='The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)',
    )


class ParentOrganisation4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BIC: Optional[constr(pattern=r'[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?')] = Field(
        None, description='The BIC from the organisation'
    )
    LEI: Optional[constr(pattern=r'^[A-Z0-9]{18,18}[0-9]{2,2}$')] = Field(
        None, description='The LEI ID of the organisation'
    )
    OrganisationName_1: OrganisationName = Field(
        ..., alias='OrganisationName', description='Organisation Name'
    )


class Organisation4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Brand: Brand4 = Field(..., description='Brand')
    ParentOrganisation: ParentOrganisation4 = Field(
        ..., description='Parent organisation'
    )


class FeesAndCharge5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeChargeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Charge applied to tier'
    )
    FeeChargeApplicationFrequency_1: Optional[FeeChargeApplicationFrequency] = Field(
        None,
        alias='FeeChargeApplicationFrequency',
        description='Frequency with which the rate, or amount is charged',
    )
    FeeChargeCalculationFrequency_1: Optional[FeeChargeCalculationFrequency] = Field(
        None,
        alias='FeeChargeCalculationFrequency',
        description='Frequency with which the rate, or amount is calculated',
    )
    FeeChargeOtherApplicationFrequency_1: Optional[
        FeeChargeOtherApplicationFrequency
    ] = Field(
        None, alias='FeeChargeOtherApplicationFrequency', description='Other Code Type'
    )
    FeeChargeOtherCalculationFrequency_1: Optional[
        FeeChargeOtherCalculationFrequency
    ] = Field(
        None, alias='FeeChargeOtherCalculationFrequency', description='Other Code Type'
    )
    FeeChargeOtherType_1: Optional[FeeChargeOtherType] = Field(
        None, alias='FeeChargeOtherType', description='Other Code Type'
    )
    FeeChargeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Fee charge rate applied to tier'
    )
    FeeChargeRateOtherType_1: Optional[FeeChargeRateOtherType] = Field(
        None, alias='FeeChargeRateOtherType', description='Other Code Type'
    )
    FeeChargeRateType_1: Optional[FeeChargeRateType] = Field(
        None, alias='FeeChargeRateType', description='Rate type other than EAR'
    )
    FeeChargeType_1: FeeChargeType = Field(
        ..., alias='FeeChargeType', description='Type of fee or charge'
    )


class FeesAndCharge6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeChargeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Charge applied to tier'
    )
    FeeChargeApplicationFrequency_1: Optional[FeeChargeApplicationFrequency] = Field(
        None,
        alias='FeeChargeApplicationFrequency',
        description='Frequency with which the rate, or amount is charged',
    )
    FeeChargeCalculationFrequency_1: Optional[FeeChargeCalculationFrequency] = Field(
        None,
        alias='FeeChargeCalculationFrequency',
        description='Frequency with which the rate, or amount is calculated',
    )
    FeeChargeOtherApplicationFrequency_1: Optional[
        FeeChargeOtherApplicationFrequency
    ] = Field(
        None, alias='FeeChargeOtherApplicationFrequency', description='Other Code Type'
    )
    FeeChargeOtherCalculationFrequency_1: Optional[
        FeeChargeOtherCalculationFrequency
    ] = Field(
        None, alias='FeeChargeOtherCalculationFrequency', description='Other Code Type'
    )
    FeeChargeOtherType_1: Optional[FeeChargeOtherType] = Field(
        None, alias='FeeChargeOtherType', description='Other Code Type'
    )
    FeeChargeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Fee charge rate applied to tier'
    )
    FeeChargeRateOtherType_1: Optional[FeeChargeRateOtherType] = Field(
        None, alias='FeeChargeRateOtherType', description='Other Code Type'
    )
    FeeChargeRateType_1: Optional[FeeChargeRateType] = Field(
        None, alias='FeeChargeRateType', description='Rate type other than EAR'
    )
    FeeChargeType_1: FeeChargeType = Field(
        ..., alias='FeeChargeType', description='Type of fee or charge'
    )


class FeesAndCharge7(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeChargeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Charge applied to tier'
    )
    FeeChargeApplicationFrequency_1: Optional[FeeChargeApplicationFrequency] = Field(
        None,
        alias='FeeChargeApplicationFrequency',
        description='Frequency with which the rate, or amount is charged',
    )
    FeeChargeCalculationFrequency_1: Optional[FeeChargeCalculationFrequency] = Field(
        None,
        alias='FeeChargeCalculationFrequency',
        description='Frequency with which the rate, or amount is calculated',
    )
    FeeChargeOtherApplicationFrequency_1: Optional[
        FeeChargeOtherApplicationFrequency
    ] = Field(
        None, alias='FeeChargeOtherApplicationFrequency', description='Other Code Type'
    )
    FeeChargeOtherCalculationFrequency_1: Optional[
        FeeChargeOtherCalculationFrequency
    ] = Field(
        None, alias='FeeChargeOtherCalculationFrequency', description='Other Code Type'
    )
    FeeChargeOtherType_1: Optional[FeeChargeOtherType] = Field(
        None, alias='FeeChargeOtherType', description='Other Code Type'
    )
    FeeChargeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Fee charge rate applied to tier'
    )
    FeeChargeRateOtherType_1: Optional[FeeChargeRateOtherType] = Field(
        None, alias='FeeChargeRateOtherType', description='Other Code Type'
    )
    FeeChargeRateType_1: Optional[FeeChargeRateType] = Field(
        None, alias='FeeChargeRateType', description='Rate type other than EAR'
    )
    FeeChargeType_1: FeeChargeType = Field(
        ..., alias='FeeChargeType', description='Type of fee or charge'
    )


class OverdraftTierBandItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    EAR: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='EAR of the Tier'
    )
    FeesAndCharges: Optional[List[FeesAndCharge7]] = None
    Notes: Optional[str] = Field(None, description='Notes on the Overdraft')
    TierBandIdentification: Optional[str] = Field(
        None, description='Identification of the tier or band'
    )
    TierValueMaximum: constr(min_length=1, max_length=15) = Field(
        ..., description='Maximum value of the tier'
    )
    TierValueMinimum: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Minimum value of the tier'
    )


class OverdraftTierBandSetItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ArrangementOtherType_1: Optional[ArrangementOtherType] = Field(
        None, alias='ArrangementOtherType', description='Other Code Type'
    )
    ArrangementType_1: ArrangementType = Field(
        ...,
        alias='ArrangementType',
        description='Defines the arrangement of the overdraft',
    )
    BufferAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Amount on overdraft that is prearranged'
    )
    CMADefinedIndicator: bool = Field(
        ...,
        description='describes that the tiers and bands are set by the CMA order, as opposed to be set by the banks',
    )
    EAR: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='EAR of the Overdraft Set'
    )
    FeesAndCharges: Optional[List[FeesAndCharge6]] = Field(
        None, description='Type of fee or charge'
    )
    Notes: Optional[str] = Field(None, description='Notes on the Overdraft')
    OverdraftTierBand: Optional[List[OverdraftTierBandItem1]] = None
    TierBandSetIdentification: Optional[str] = Field(
        None, description='Identification of the set of tiers or bands'
    )


class OverdraftItem1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeChargeNegotiableIndicator_1: Optional[FeeChargeNegotiableIndicator] = Field(
        None,
        alias='FeeChargeNegotiableIndicator',
        description='Fee Charge negotiable Indicator',
    )
    FeesAndCharges: Optional[List[FeesAndCharge5]] = None
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    MaximumMonthlyOverdraftCharge: Optional[
        constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')
    ] = Field(
        None, description='Maximum Monthly Charge (MMC) for Overdraft fee and charges.'
    )
    Notes: Optional[str] = Field(None, description='Notes on the overdraft')
    OverdraftProductState_1: Optional[OverdraftProductState] = Field(
        None,
        alias='OverdraftProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )
    OverdraftTierBandSet: Optional[List[OverdraftTierBandSetItem1]] = Field(
        None, description='Overdraft Tier Band Set'
    )
    OverdraftType_1: Optional[OverdraftType] = Field(
        None,
        alias='OverdraftType',
        description='Defines if the overdraft facility is committed ',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')
    Term: Optional[str] = Field(
        None, description='The duration of the overdraft, if it is non permanent'
    )


class ProductSegmentEnum2(Enum):
    Basic = 'Basic'
    Business = 'Business'
    General = 'General'
    Graduate = 'Graduate'
    International = 'International'
    Packaged = 'Packaged'
    Personal = 'Personal'
    Premium = 'Premium'
    Reward = 'Reward'
    SME = 'SME'
    Student = 'Student'
    YoungAdult = 'YoungAdult'
    Youth = 'Youth'


class ProductType2(Enum):
    PCA = 'PCA'


class Datum4(BaseModel):
    AccessChannels: List[AccessChannel] = Field(
        ...,
        description='Ways to interact with the bank when managing account',
        min_length=1,
    )
    Benefits: Benefits2 = Field(..., description='Benefit')
    CAPricing: List[CAPricingItem2] = Field(..., min_length=1)
    CardNotes: Optional[str] = Field(
        None, description='Optional additional notes to supplement the card details'
    )
    CardType: List[CardTypeEnum] = Field(
        ..., description='Card Type available', min_length=1
    )
    CardWithdrawalLimit: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ...,
        description='The daily Limit that a customer can get via the ATM. This describes the default limit rather than the maximum',
    )
    ChequeBookAvailable: bool = Field(..., description='Can a chequebook be issued')
    Contactless: bool = Field(
        ..., description='Does the card issued have contactless facility'
    )
    CreditInterest: CreditInterest1 = Field(..., description='Credit Interest')
    CreditScoringPartOfAccountOpeningForGettingAnAccount: bool = Field(
        ...,
        description='Indicates whether a credit check performed on an inquiry to open an account is submitted',
    )
    CreditScoringPartOfAccountOpeningForIDVerification: Optional[bool] = Field(
        None,
        description='Indicates whether a credit check is used to check the address of a potential new account holder',
    )
    CreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScore: Optional[
        List[
            CreditScoringPartOfAccountOpeningIDVerificationIsAHardOrSoftCreditScoreEnum
        ]
    ] = None
    CreditScoringPartOfAccountOpeningIDVerificationText: Optional[List[str]] = Field(
        None, description='Details on the specific credit scoring'
    )
    CreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScore: Optional[
        List[CreditScoringPartOfAccountOpeningIsAHardOrSoftCreditScoreEnum]
    ] = Field(None, description='Describes the type of credit scoring')
    CreditScoringPartOfAccountOpeningText: Optional[str] = Field(
        None, description='Details on the specific credit scoring'
    )
    Currency: List[CurrencyItem] = Field(
        ...,
        description='Currency of the Account. Default to GBP at present',
        min_length=1,
    )
    Eligibility: Eligibility2 = Field(..., description='Eligibility')
    Feature: Optional[List[FeatureItem1]] = None
    FeesAndCharges: List[FeesAndCharge4] = Field(..., min_length=1)
    InternationalPaymentsSupported: bool = Field(
        ..., description='Indicates that the account supports international payments'
    )
    MaximumMonthlyCharge: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='The maximum Relevant Charges that could accrue'
    )
    MobileWallet: Optional[List[MobileWalletEnum]] = Field(
        None,
        description='Mobile wallet supported by this product. A mobile wallet being any electronic device that allows an individual to make electronic commerce transactions',
    )
    Organisation: Organisation4 = Field(..., description='Organisation')
    Overdraft: Optional[List[OverdraftItem1]] = None
    OverdraftOffered: bool = Field(
        ..., description='Indicates whether an overdraft offered for this account'
    )
    ProductDescription: str = Field(
        ...,
        description='Description of the product provided by the parent organisation',
    )
    ProductIdentifier: str = Field(
        ...,
        description='Identifier within the parent organisation for the product. Must be unique in the organisation',
    )
    ProductName: Optional[str] = Field(
        None,
        description='The name of the product used for marketing purposes from a customer perspective. i.e. what the customer would recognise',
    )
    ProductSegment: List[ProductSegmentEnum2] = Field(..., min_length=1)
    ProductType: ProductType2 = Field(
        ..., description='Descriptive code for the product category'
    )
    ProductURL: List[AnyUrl] = Field(
        ...,
        description='URL provided by the organisation which redirects to the product (on live products only). There might be more than one product at a given URL',
    )
    TsandCs: List[str] = Field(
        ...,
        description='URL provided by the parent organisation which redirects to the current T&Cs',
        min_length=1,
    )


class Meta4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Agreement_1: Agreement = Field(..., alias='Agreement')
    LastUpdated: datetime
    License_1: License = Field(..., alias='License', description='Open Banking License')
    TermsOfUse_1: TermsOfUse = Field(
        ..., alias='TermsOfUse', description='Open Banking Terms of Use'
    )
    TotalResults: int


class PersonalCurrentAccountsGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[Datum4]
    meta: Meta4 = Field(..., title='Meta data')


class Description20(Enum):
    You_have_sent_a_request_which_could_not_be_understood_ = (
        'You have sent a request which could not be understood.'
    )


class Status20(Enum):
    field_400 = '400'


class Title20(Enum):
    Bad_request = 'Bad request'


class PersonalCurrentAccountsGetResponse1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description20
    status: Status20
    title: Title20


class Description21(Enum):
    Your_client_has_failed_to_submit_a_request__and_a_timeout_has_occurred_ = (
        'Your client has failed to submit a request, and a timeout has occurred.'
    )


class Status21(Enum):
    field_408 = '408'


class Title21(Enum):
    Client_timeout = 'Client timeout'


class PersonalCurrentAccountsGetResponse2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description21
    status: Status21
    title: Title21


class Description22(Enum):
    You_have_requested_this_resource_too_often__Slow_down_ = (
        'You have requested this resource too often. Slow down.'
    )


class Status22(Enum):
    field_429 = '429'


class Title22(Enum):
    Too_many_requests = 'Too many requests'


class PersonalCurrentAccountsGetResponse3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description22
    status: Status22
    title: Title22


class Description23(Enum):
    An_error_occurred_on_the_server__No_further_information_is_available_ = (
        'An error occurred on the server. No further information is available.'
    )


class Status23(Enum):
    field_500 = '500'


class Title23(Enum):
    Internal_server_error = 'Internal server error'


class PersonalCurrentAccountsGetResponse4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description23
    status: Status23
    title: Title23


class Description24(Enum):
    The_service_is_temporarily_unavailable_ = 'The service is temporarily unavailable.'


class Status24(Enum):
    field_503 = '503'


class Title24(Enum):
    Service_temporarily_unavailable = 'Service temporarily unavailable'


class PersonalCurrentAccountsGetResponse5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description24
    status: Status24
    title: Title24


class PersonalCurrentAccountsGetResponse6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='Further details describing the error')
    status: str = Field(..., description='This corresponds to the HTTP status code')
    title: str = Field(..., description='A short title of the type of error')


class PersonalCurrentAccountsHeadResponse(BaseModel):
    pass


class BenefitDetailItem3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDescription: Optional[str] = Field(
        None, description='A textual explanation of what the benefit is'
    )
    BenefitID: Optional[str] = Field(
        None, description='Unique benefit identifier per organisation'
    )
    BenefitName: Optional[str] = Field(None, description='The name of the benefit')
    BenefitType: Optional[str] = Field(
        None, description='Type that represents the nature of the benefit'
    )
    BenefitValue: Optional[str] = Field(
        None,
        description='The value or values permissible for a specific benefit for an individual product representing a product characteristic',
    )
    Counter: Optional[int] = Field(
        None, description='Counter for the criteria (e.g. number of DD)'
    )
    CriteriaType: Optional[List[CriteriaTypeEnum]] = None
    DefaultToAccounts: Optional[bool] = Field(
        None, description='Is the benefit part of the default account'
    )
    MaximumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Maximum amount for the criteria'
    )
    MinimumCriteria: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum amount for the criteria'
    )
    PromotionEndDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the end date is when the benefit is no longer applicable',
    )
    PromotionStartDate: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(
        None,
        description='If the benefit is temporal the start date is when the benefit comes into effect',
    )


class BenefitItem3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitDetail: Optional[List[BenefitDetailItem3]] = None
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date in days',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class BenefitGroupItem3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BenefitItem: BenefitItem3 = Field(..., description='Benefit Item')
    BenefitSubType_1: Optional[BenefitSubType] = Field(
        None, alias='BenefitSubType', description='Benefit Subtype Code'
    )


class Benefits3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Benefit: bool = Field(
        ..., description='Describe  one or more benefits if they exist'
    )
    BenefitGroup: Optional[List[BenefitGroupItem3]] = None


class CustomerAccessChannel(Enum):
    Branch = 'Branch'
    MobileBankingApp = 'MobileBankingApp'
    Online = 'Online'
    Phone = 'Phone'
    Post = 'Post'
    PostOffice = 'PostOffice'
    Text = 'Text'


class Eligibility3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    AgeRestricted: bool = Field(
        ..., description="Indicates a customer's age is part of eligibility criteria"
    )
    AnnualBusinessTurnover: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Annual Business Turnover'
    )
    AnnualBusinessTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Annual Business Turnover Currency'
    )
    Description: str = Field(..., description='One paragraph detailing the eligibility')
    EligibilityName: Optional[str] = Field(
        None,
        description='Free text description, denotes non standard eligibilities not included in the code list',
    )
    EligibilityNotes: Optional[str] = Field(
        None,
        description='Optional additional notes to supplement the eligibility conditions. Only used for very specific conditions',
    )
    EligibilityType_1: Optional[EligibilityType] = Field(
        None, alias='EligibilityType', description='Eligibility type'
    )
    IncomeCondition: Optional[str] = Field(
        None,
        description='Stipulates any particular definition of income that applies to the income eligibility and/or method by which income must paid into the account (eg Salary DD)',
    )
    IncomeTurnoverRelated: bool = Field(
        ..., description='Indicates if eligibility linked to income'
    )
    MarketingEligibility: Optional[List[MarketingEligibilityEnum]] = None
    MaxNumberOfAccounts: Optional[str] = Field(
        None, description='Maximum number of the same prodcut the customer may hold'
    )
    MaximumAge: Optional[int] = Field(
        None, description='Maximum age, in years, allowed to hold the account'
    )
    MaximumAgeToOpen: Optional[int] = Field(
        None, description='Maximum age, in years, to open an account'
    )
    MaximumOpeningAmount: Optional[bool] = Field(
        None, description='A maximum amount to be deposited at opening'
    )
    MinIncomeTurnoverPaidIntoAccount: Optional[int] = Field(
        None, description='Minimum Income Amount required to paid into the account'
    )
    MinimumAge: Optional[int] = Field(
        None, description='Minimum age, in years, required to hold an account'
    )
    MinimumDeposit: Optional[bool] = Field(
        None, description='A minimum deposit required to hold this account'
    )
    MinimumIncomeFrequency_1: Optional[MinimumIncomeFrequency] = Field(
        None,
        alias='MinimumIncomeFrequency',
        description='The frequency that the minimum mentioned before is deposited in the account. Yearly is very important for premium accounts',
    )
    MinimumIncomeTurnoverAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(
            None, description='Minimum income / Turnover required to hold the product'
        )
    )
    MinimumIncomeTurnoverCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum income / Turnover Currency'
    )
    MinimumOperatingBalance: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Operating Balance'
    )
    MinimumOperatingBalanceCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None, description='Minimum Operating Balance currency'
    )
    MinimumOperatingBalanceExists: Optional[bool] = Field(
        None, description='Is there a Minimum Operating Balance?'
    )
    OpeningDepositMaximumAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = (
        Field(None, description='Maximum Amount to be depositing at opening')
    )
    OpeningDepositMaximumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OpeningDepositMinimum: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Minimum Amount to be held on account'
    )
    OpeningDepositMinimumCurrency: Optional[constr(pattern=r'[A-Z]{3}')] = Field(
        None,
        description='The currency of the Minimum Amount to be depositing at opening',
    )
    OtherFinancialHoldingRequired: bool = Field(
        ...,
        description='Indicates that it is necessary to hold another product with the bank in order to be eligible for this product or feature',
    )
    PreviousBankruptcy: bool = Field(
        ...,
        description='Describes if a previous bankruptcy / insolvency disqualfies for this account Details in ELI-280',
    )
    ResidencyRestricted: bool = Field(
        ...,
        description="Indicates a customer's residency forms part of the eligibility criteria",
    )
    ResidencyRestrictedRegion_1: Optional[ResidencyRestrictedRegion] = Field(
        None,
        alias='ResidencyRestrictedRegion',
        description='Indicates a customer must be current resident of a geographic area/country',
    )
    SingleJointIncome_1: Optional[SingleJointIncome] = Field(
        None,
        alias='SingleJointIncome',
        description='Minimum Income Source. For certain products a minimum income is required. This can be mandated as to the single income or to a joint income. This field describes this',
    )
    ThirdSectorOrganisations: bool = Field(
        ...,
        description='Is the product available to operate as a Clubs or Societies account?',
    )


class FeeSubDetails2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeAmount: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeFrequency_1: FeeFrequency = Field(
        ..., alias='FeeFrequency', description='Triggering frequency of the fee'
    )
    FeeHigherTier: Optional[int] = Field(
        None,
        description='Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range',
    )
    FeeLowerTier: Optional[int] = Field(
        None,
        description='Lower occurrence / range boundary e.g. For returned cheques this could be 0, which means the first returned cheque fits into this range',
    )
    FeeMax: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeMin: Optional[constr(pattern=r'^-?\d{1,10}\.\d{1,2}$')] = Field(
        None, description='Fee in GBP'
    )
    FeeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='% Rate'
    )
    FeesAndChargesNotes: Optional[str] = Field(
        None, description='Supplementary information for fees and charges'
    )
    Negotiable: bool = Field(
        ...,
        description='Indicates that this Fee Rate or Fee Amount is negotiable based on risk or other factor',
    )
    RepresentativeRate: Optional[constr(pattern=r'^-?\d{1,3}\.\d{1,4}$')] = Field(
        None, description='Representative Rate'
    )


class FeeDetail5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeSubDetails: FeeSubDetails2 = Field(..., description='Fee Sub Details')
    FeeType_1: FeeType = Field(
        ..., alias='FeeType', description='A description of the Fee type'
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    Other: Optional[str] = Field(None, description='Describe other fee type')
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeeDetail4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    FeeDetail: FeeDetail5 = Field(..., description='Fee Detail')
    FeeSubType_1: FeeSubType = Field(
        ..., alias='FeeSubType', description='Fee Sub Type code'
    )


class Fees2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    FeeDetails: List[FeeDetail4] = Field(..., min_length=1)
    FeeHigherTier: Optional[int] = Field(
        None,
        description='Higher occurrence / range boundary e.g. For returned cheques this could be 10, which means the first 10 returned cheque fits into this range',
    )
    FeeLowerTier: Optional[int] = Field(
        None,
        description='Lower occurrence / range boundary e.g.. For returned cheques this could be 0, which means the first returned cheque fits into this range',
    )
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')


class FeesAndCharge8(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Fees: Fees2 = Field(..., description='Fees')
    ProductState_1: ProductState = Field(
        ...,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )


class LoanLengthIncrement(Enum):
    field_1_year = '1 year'
    field_2_years = '2 years'
    field_3_years = '3 years'
    field_4_years = '4 years'
    field_5_years = '5 years'


class RepaymentFrequencyEnum(Enum):
    Daily = 'Daily'
    Flexible = 'Flexible'
    Fortnightly = 'Fortnightly'
    HalfYearly = 'HalfYearly'
    Monthly = 'Monthly'
    Quarterly = 'Quarterly'
    Weekly = 'Weekly'
    Yearly = 'Yearly'


class SizeIncrement(Enum):
    field_5000 = '£5000'
    field_10000 = '£10000'
    field_15000 = '£15000'
    field_20000 = '£20000'
    field_25000 = '£25000'
    Other = 'Other'
    TierMaximum = 'TierMaximum'
    TierMinimum = 'TierMinimum'


class LoanPricingItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    IndicativeRate: str
    LoanLengthIncrement_1: LoanLengthIncrement = Field(
        ..., alias='LoanLengthIncrement', description='Loan Length Increments'
    )
    LoanLengthIncrementLower: int
    LoanLengthIncrementUpper: int
    LoanSizeBandLower: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Monetary amount without currency'
    )
    LoanSizeBandUpper: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Monetary amount without currency'
    )
    Negotiable: bool
    RateComparisonType_1: Optional[RateComparisonType] = Field(
        None, alias='RateComparisonType', description='Rate Comparison Type'
    )
    RepaymentFrequency: List[RepaymentFrequencyEnum] = Field(..., min_length=1)
    SizeIncrement_1: SizeIncrement = Field(
        ...,
        alias='SizeIncrement',
        description='Identifier for tier only where it has been supplied under Part 8 (article 32 or the CMA order), value reflects upper tier value',
    )


class LoanItemItem(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    CCARegulatedEntity: bool
    DateOfChange: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Date of the change if it refers to future terms')
    IsALowInterestRepaymentStartPossible: bool
    IsThisAnInterestOnlyLoan: bool
    LengthPromotionalInDays: Optional[int] = Field(
        None,
        description='Describes the length if only a duration is given instead of a date in days',
    )
    LoanPricing: Optional[List[LoanPricingItem]] = None
    ProductState_1: ProductState = Field(
        ...,
        alias='ProductState',
        description='Describes if the offering is promotional or a description of a future state.',
    )
    StartPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the start date')
    StopPromotionOrFutureTerms: Optional[
        constr(
            pattern=r'^[0-9]{4}-(0[1-9]|(1[0|1|2]))-((0[1-9])|((1|2)[0-9])|(30|31))$'
        )
    ] = Field(None, description='Describes the end date')
    WillTheLoanBePaidInTrancheDrawdowns: bool


class Brand5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    TrademarkID: constr(min_length=1, max_length=35) = Field(
        ...,
        description='The trademark number that has been registered with the Intellectual Property Office. Note: The 2 letter IPO prefix should be omitted',
    )
    TrademarkIPOCode_1: TrademarkIPOCode = Field(
        ...,
        alias='TrademarkIPOCode',
        description='The Intellectual Property Office (IPO) is the official body responsible for intellectual property (IP) rights including patents, designs, trademarks and copyright. (Code: UK or EU only)',
    )


class ParentOrganisation5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    BIC: Optional[constr(pattern=r'[A-Z]{6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3})?')] = Field(
        None, description='The BIC from the organisation'
    )
    LEI: Optional[constr(pattern=r'^[A-Z0-9]{18,18}[0-9]{2,2}$')] = Field(
        None, description='The LEI ID of the organisation'
    )
    OrganisationName_1: OrganisationName = Field(
        ..., alias='OrganisationName', description='Organisation Name'
    )


class Organisation5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Brand: Brand5 = Field(..., description='Brand')
    ParentOrganisation: ParentOrganisation5 = Field(
        ..., description='Parent organisation'
    )


class ProductSegmentEnum3(Enum):
    AgricultureSector = 'AgricultureSector'
    AllSegmentsCorporate = 'AllSegmentsCorporate'
    Corporate = 'Corporate'
    FixedGroup = 'FixedGroup'
    FlexibleBusinessLoan = 'FlexibleBusinessLoan'
    GovernmentScheme = 'GovernmentScheme'
    NewCustomersOnly = 'NewCustomersOnly'
    SmallLoan = 'SmallLoan'
    SpecialisedSector = 'SpecialisedSector'
    SwitchersOnly = 'SwitchersOnly'


class ProductTypeName(Enum):
    FlexibleBusinessLoan = 'FlexibleBusinessLoan'
    SmallBusinessLoan = 'SmallBusinessLoan'
    SmeUnsecuredLoan = 'SmeUnsecuredLoan'


class Datum5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    ArrearsTreatment: Optional[str] = Field(None, description='Arrears treatment')
    Benefits: Benefits3 = Field(..., description='Benefit')
    Currency: List[CurrencyItem] = Field(
        ...,
        description='Currency of the Account. Default to GBP at present',
        min_length=1,
    )
    CustomerAccessChannels: List[CustomerAccessChannel] = Field(
        ..., description='Ways to interact with the bank', min_length=1
    )
    Eligibility: Eligibility3 = Field(..., description='Eligibility')
    FeesAndCharges: List[FeesAndCharge8] = Field(..., min_length=1)
    LoanItem: List[LoanItemItem]
    MaximumLoanAmount: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Maximum loan amount'
    )
    MaximumLoanTerm: int = Field(..., description='Maximum loan term (Days)')
    MinimumLoanAmount: constr(pattern=r'^-?\d{1,10}\.\d{1,2}$') = Field(
        ..., description='Minimum loan amount'
    )
    MinimumLoanTerm: int = Field(..., description='Minimum term (Days)')
    Organisation: Organisation5 = Field(..., description='Organisation')
    PaymentHoliday: bool = Field(
        ..., description='Indicates whether a repayment holiday is allowed'
    )
    ProductDescription: str = Field(
        ...,
        description='Description of the product provided by the parent Organisation',
    )
    ProductIdentifier: str = Field(
        ...,
        description='Identifier within the parent organisation for the product. Must be unique in the organisation',
    )
    ProductName: str = Field(
        ...,
        description='The short product or marketing name assigned by the parent organisation',
    )
    ProductSegment: List[ProductSegmentEnum3] = Field(..., min_length=1)
    ProductTypeName_1: ProductTypeName = Field(
        ...,
        alias='ProductTypeName',
        description='Descriptive code for the product category',
    )
    ProductURL: List[AnyUrl]
    TsandCs: List[str] = Field(
        ...,
        description='URL provided by the parent organisation which redirects to the T&Cs',
        min_length=1,
    )


class Meta5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    Agreement_1: Agreement = Field(..., alias='Agreement')
    LastUpdated: datetime
    License_1: License = Field(..., alias='License', description='Open Banking License')
    TermsOfUse_1: TermsOfUse = Field(
        ..., alias='TermsOfUse', description='Open Banking Terms of Use'
    )
    TotalResults: int


class UnsecuredSmeLoansGetResponse(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    data: List[Datum5]
    meta: Meta5 = Field(..., title='Meta data')


class Description25(Enum):
    You_have_sent_a_request_which_could_not_be_understood_ = (
        'You have sent a request which could not be understood.'
    )


class Status25(Enum):
    field_400 = '400'


class Title25(Enum):
    Bad_request = 'Bad request'


class UnsecuredSmeLoansGetResponse1(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description25
    status: Status25
    title: Title25


class Description26(Enum):
    Your_client_has_failed_to_submit_a_request__and_a_timeout_has_occurred_ = (
        'Your client has failed to submit a request, and a timeout has occurred.'
    )


class Status26(Enum):
    field_408 = '408'


class Title26(Enum):
    Client_timeout = 'Client timeout'


class UnsecuredSmeLoansGetResponse2(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description26
    status: Status26
    title: Title26


class Description27(Enum):
    You_have_requested_this_resource_too_often__Slow_down_ = (
        'You have requested this resource too often. Slow down.'
    )


class Status27(Enum):
    field_429 = '429'


class Title27(Enum):
    Too_many_requests = 'Too many requests'


class UnsecuredSmeLoansGetResponse3(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description27
    status: Status27
    title: Title27


class Description28(Enum):
    An_error_occurred_on_the_server__No_further_information_is_available_ = (
        'An error occurred on the server. No further information is available.'
    )


class Status28(Enum):
    field_500 = '500'


class Title28(Enum):
    Internal_server_error = 'Internal server error'


class UnsecuredSmeLoansGetResponse4(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description28
    status: Status28
    title: Title28


class Description29(Enum):
    The_service_is_temporarily_unavailable_ = 'The service is temporarily unavailable.'


class Status29(Enum):
    field_503 = '503'


class Title29(Enum):
    Service_temporarily_unavailable = 'Service temporarily unavailable'


class UnsecuredSmeLoansGetResponse5(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: Description29
    status: Status29
    title: Title29


class UnsecuredSmeLoansGetResponse6(BaseModel):
    model_config = ConfigDict(
        extra='forbid',
    )
    description: str = Field(..., description='Further details describing the error')
    status: str = Field(..., description='This corresponds to the HTTP status code')
    title: str = Field(..., description='A short title of the type of error')


class UnsecuredSmeLoansHeadResponse(BaseModel):
    pass
